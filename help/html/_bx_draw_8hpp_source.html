<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BxEngine: BxDraw.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">BxEngine
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">BxDraw.hpp</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#pragma once</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#include &quot;BxUtil.hpp&quot;</span>
<a name="l00003"></a>00003 
<a name="l00005"></a><a class="code" href="class_bx_draw_form.html">00005</a> <span class="keyword">class </span><a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>
<a name="l00006"></a>00006 {
<a name="l00007"></a>00007 <span class="keyword">public</span>:
<a name="l00008"></a>00008     <span class="keyword">enum</span> blendflag {blendflag_null = 0, blendflag_alpha = 1, blendflag_sprite = 2};
<a name="l00009"></a>00009     <span class="keyword">typedef</span> void (*OnFormMethod)(<a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp; srcClass, <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> srcRect, pixel_dst* rowBuffer, <span class="keyword">const</span> uint rowLength,
<a name="l00010"></a>00010         <span class="keyword">const</span> fint x, <span class="keyword">const</span> fint y, <span class="keyword">const</span> fint xVec, <span class="keyword">const</span> fint yVec, <span class="keyword">const</span> byte* blendSpriteTable, <span class="keyword">const</span> byte* blendAlphaTable);
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="keyword">protected</span>:
<a name="l00013"></a>00013     <a class="code" href="structarea.html" title="area구조체 : w, h, hx, hy">area</a> Area;
<a name="l00014"></a>00014     blendflag Flag;
<a name="l00015"></a>00015 <span class="preprocessor">    #ifdef __BX_OPENGL</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>    <span class="keywordtype">void</span>* FormGLSource;
<a name="l00017"></a>00017     id_opengl_form FormGL;
<a name="l00018"></a>00018 <span class="preprocessor">    #endif</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020     <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>()
<a name="l00021"></a>00021     {
<a name="l00022"></a>00022         Area.w = 0;
<a name="l00023"></a>00023         Area.h = 0;
<a name="l00024"></a>00024         Area.hx = 0;
<a name="l00025"></a>00025         Area.hy = 0;
<a name="l00026"></a>00026         Flag = blendflag_null;
<a name="l00027"></a>00027 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>        FormGLSource = null;
<a name="l00029"></a>00029         FormGL = null;
<a name="l00030"></a>00030 <span class="preprocessor">        #endif</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>    }
<a name="l00032"></a>00032     <span class="keyword">virtual</span> ~<a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>()
<a name="l00033"></a>00033     {
<a name="l00034"></a>00034 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>        BxCore::OpenGL2D::FreeForm(FormGL);
<a name="l00036"></a>00036 <span class="preprocessor">        #endif</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>    }
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">public</span>:
<a name="l00040"></a>00040     <span class="keyword">inline</span> <span class="keywordtype">int</span> Width() {<span class="keywordflow">return</span> Area.w;}
<a name="l00041"></a>00041     <span class="keyword">inline</span> <span class="keywordtype">int</span> Height() {<span class="keywordflow">return</span> Area.h;}
<a name="l00042"></a>00042     <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structarea.html" title="area구조체 : w, h, hx, hy">area</a>* GetArea() {<span class="keywordflow">return</span> &amp;Area;}
<a name="l00043"></a>00043     <span class="keyword">inline</span> <span class="keywordtype">void</span> SetHotspot(<span class="keyword">const</span> <span class="keywordtype">int</span> hx, <span class="keyword">const</span> <span class="keywordtype">int</span> hy) {Area.hx = hx; Area.hy = hy;}
<a name="l00044"></a>00044 
<a name="l00045"></a>00045     global_func <span class="keyword">const</span> <span class="keywordtype">int</span> CalcTextureSize(<span class="keyword">const</span> <span class="keywordtype">int</span> RealSize)
<a name="l00046"></a>00046     {
<a name="l00047"></a>00047 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>        <span class="keywordflow">return</span> RealSize;
<a name="l00049"></a>00049 <span class="preprocessor">        #else</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>        <span class="keywordtype">int</span> Result = 1;
<a name="l00051"></a>00051         <span class="keywordflow">while</span>(Result &lt; RealSize)
<a name="l00052"></a>00052             Result &lt;&lt;= 1;
<a name="l00053"></a>00053         <span class="keywordflow">return</span> Result;
<a name="l00054"></a>00054 <span class="preprocessor">        #endif</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>    }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057     global_func <span class="keyword">const</span> <span class="keywordtype">int</span> CalcTextureLevel(<span class="keywordtype">int</span> TextureSize)
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059         <span class="keywordtype">int</span> Result = 0;
<a name="l00060"></a>00060         <span class="keywordflow">while</span>(TextureSize &gt;&gt;= 1)
<a name="l00061"></a>00061             ++Result;
<a name="l00062"></a>00062         <span class="keywordflow">return</span> Result;
<a name="l00063"></a>00063     }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="keyword">virtual</span> OnFormMethod GetFormMethod(maskoperate operate, maskflag flag) = 0;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">    #ifdef __BX_OPENGL</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>    id_opengl_form GetFormGL()
<a name="l00069"></a>00069     {
<a name="l00070"></a>00070         _UpdateFormGL();
<a name="l00071"></a>00071         <span class="keywordflow">return</span> FormGL;
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073 <span class="preprocessor">    #endif</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="keyword">protected</span>:
<a name="l00076"></a>00076     global_func <span class="keywordtype">void</span> OnFormNoPrint(<a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp;, <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a>, pixel_dst*, <span class="keyword">const</span> uint, <span class="keyword">const</span> fint,
<a name="l00077"></a>00077         <span class="keyword">const</span> fint, <span class="keyword">const</span> fint, <span class="keyword">const</span> fint, <span class="keyword">const</span> byte*, <span class="keyword">const</span> byte*)
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079     }
<a name="l00080"></a>00080 <span class="preprocessor">    #ifdef __BX_OPENGL</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> _UpdateFormGL() = 0;
<a name="l00082"></a>00082 <span class="preprocessor">    #endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>};
<a name="l00084"></a>00084 
<a name="l00086"></a><a class="code" href="namespace_bx_draw_global.html">00086</a> <span class="keyword">namespace </span>BxDrawGlobal
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088     <span class="keyword">enum</span> option {FILL, DRAW};
<a name="l00089"></a>00089 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     FUNCTOR_BEGIN(XY, <span class="keyword">const</span> <a class="code" href="structpoint.html" title="point구조체 : x, y">point</a>, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
<a name="l00098"></a>00098     {
<a name="l00099"></a>00099         <span class="keyword">const</span> <a class="code" href="structpoint.html" title="point구조체 : x, y">point</a> Result = {x, y};
<a name="l00100"></a>00100         <span class="keywordflow">return</span> Result;
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102     FUNCTOR_END(XY)
<a name="l00104"></a>00104 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     FUNCTOR_BEGIN(WH, <span class="keyword">const</span> <a class="code" href="structsize.html" title="size구조체 : w, h">size</a>, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
<a name="l00113"></a>00113     {
<a name="l00114"></a>00114         <span class="keyword">const</span> <a class="code" href="structsize.html" title="size구조체 : w, h">size</a> Result = {w, h};
<a name="l00115"></a>00115         <span class="keywordflow">return</span> Result;
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117     FUNCTOR_END(WH)
<a name="l00119"></a>00119 
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     FUNCTOR_BEGIN(XYWH, <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a>, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> w = size::max, <span class="keywordtype">int</span> h = size::max)
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131         <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Result = {x, y, x + w, y + h};
<a name="l00132"></a>00132         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;가로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.r - Result.l &lt;= size::max);
<a name="l00133"></a>00133         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;세로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.b - Result.t &lt;= size::max);
<a name="l00134"></a>00134         <span class="keywordflow">return</span> Result;
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136     FUNCTOR_END(XYWH)
<a name="l00138"></a>00138 
<a name="l00147"></a><a class="code" href="namespace_bx_draw_global.html#ae284872147dbce083bbdddfbcf6cf057">00147</a>     static inline const <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> <a class="code" href="namespace_bx_draw_global.html#ae284872147dbce083bbdddfbcf6cf057" title="위치제작">XYXY</a>(<span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1, <span class="keywordtype">int</span> x2, <span class="keywordtype">int</span> y2)
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149         <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Result = {x1, y1, x2, y2};
<a name="l00150"></a>00150         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;가로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.r - Result.l &lt;= size::max);
<a name="l00151"></a>00151         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;세로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.b - Result.t &lt;= size::max);
<a name="l00152"></a>00152         <span class="keywordflow">return</span> Result;
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154 
<a name="l00162"></a><a class="code" href="namespace_bx_draw_global.html#ad15e4e6ddd48750b45d1262cad126e8d">00162</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> <a class="code" href="namespace_bx_draw_global.html#ad15e4e6ddd48750b45d1262cad126e8d" title="중점식 영역제작">XYR</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> r)
<a name="l00163"></a>00163     {
<a name="l00164"></a>00164         <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Result = {x - r, y - r, x + r, y + r};
<a name="l00165"></a>00165         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;가로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.r - Result.l &lt;= size::max);
<a name="l00166"></a>00166         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;세로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.b - Result.t &lt;= size::max);
<a name="l00167"></a>00167         <span class="keywordflow">return</span> Result;
<a name="l00168"></a>00168     }
<a name="l00169"></a>00169 
<a name="l00178"></a><a class="code" href="namespace_bx_draw_global.html#aaad2b306eb1a3cdb820f97ec41543e96">00178</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> <a class="code" href="namespace_bx_draw_global.html#aaad2b306eb1a3cdb820f97ec41543e96" title="중점식 영역제작">XYRR</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> wr, <span class="keywordtype">int</span> hr)
<a name="l00179"></a>00179     {
<a name="l00180"></a>00180         <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Result = {x - wr, y - hr, x + wr, y + hr};
<a name="l00181"></a>00181         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;가로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.r - Result.l &lt;= size::max);
<a name="l00182"></a>00182         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;세로길이가 MAXSIZE를 초과합니다&gt;&quot;</span>, Result.b - Result.t &lt;= size::max);
<a name="l00183"></a>00183         <span class="keywordflow">return</span> Result;
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00193"></a><a class="code" href="namespace_bx_draw_global.html#a64389bd5a1f1f7affa88ff54ff45b210">00193</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a>&amp; <a class="code" href="namespace_bx_draw_global.html#a64389bd5a1f1f7affa88ff54ff45b210" title="가변인자식 다각영역제작">XYS</a>(uint count, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, ...)
<a name="l00194"></a>00194     {
<a name="l00195"></a>00195         global_data <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a> Result = {0,};
<a name="l00196"></a>00196         Result.count = count;
<a name="l00197"></a>00197         Result.pt[0].x = x;
<a name="l00198"></a>00198         Result.pt[0].y = y;
<a name="l00199"></a>00199         va_list List;
<a name="l00200"></a>00200         va_start(List, y);
<a name="l00201"></a>00201         <span class="keywordflow">for</span>(uint i = 1; i &lt; count; ++i)
<a name="l00202"></a>00202         {
<a name="l00203"></a>00203             Result.pt[i].x = va_arg(List, <span class="keywordtype">int</span>);
<a name="l00204"></a>00204             Result.pt[i].y = va_arg(List, <span class="keywordtype">int</span>);
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206         va_end(List);
<a name="l00207"></a>00207         <span class="keywordflow">return</span> Result;
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209 
<a name="l00218"></a><a class="code" href="namespace_bx_draw_global.html#a376a0fbfac5b71f4321dd6c8e3ccb26a">00218</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structvertexs.html" title="vertexs구조체 : count, {x, y, z}, ...">vertexs</a>&amp; <a class="code" href="namespace_bx_draw_global.html#a376a0fbfac5b71f4321dd6c8e3ccb26a" title="가변인자식 3D다각영역제작">XYZS</a>(uint count, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z, ...)
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220         global_data <a class="code" href="structvertexs.html" title="vertexs구조체 : count, {x, y, z}, ...">vertexs</a> Result = {0,};
<a name="l00221"></a>00221         Result.count = count;
<a name="l00222"></a>00222         Result.vt[0].x = x;
<a name="l00223"></a>00223         Result.vt[0].y = y;
<a name="l00224"></a>00224         Result.vt[0].z = z;
<a name="l00225"></a>00225         va_list List;
<a name="l00226"></a>00226         va_start(List, z);
<a name="l00227"></a>00227         <span class="keywordflow">for</span>(uint i = 1; i &lt; count; ++i)
<a name="l00228"></a>00228         {
<a name="l00229"></a>00229             Result.vt[i].x = va_arg(List, <span class="keywordtype">int</span>);
<a name="l00230"></a>00230             Result.vt[i].y = va_arg(List, <span class="keywordtype">int</span>);
<a name="l00231"></a>00231             Result.vt[i].z = va_arg(List, <span class="keywordtype">int</span>);
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233         va_end(List);
<a name="l00234"></a>00234         <span class="keywordflow">return</span> Result;
<a name="l00235"></a>00235     }
<a name="l00236"></a>00236 
<a name="l00243"></a><a class="code" href="namespace_bx_draw_global.html#ad0b9b4235434c42dbaaff250b70589a1">00243</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a>&amp; <a class="code" href="namespace_bx_draw_global.html#ad0b9b4235434c42dbaaff250b70589a1" title="배열식 다각영역제작">XYARRAY</a>(uint count, <span class="keywordtype">int</span>* xy)
<a name="l00244"></a>00244     {
<a name="l00245"></a>00245         global_data <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a> Result = {0,};
<a name="l00246"></a>00246         Result.count = count;
<a name="l00247"></a>00247         <span class="keywordflow">for</span>(uint i = 0; i &lt; count; ++i)
<a name="l00248"></a>00248         {
<a name="l00249"></a>00249             Result.pt[i].x = *(xy++);
<a name="l00250"></a>00250             Result.pt[i].y = *(xy++);
<a name="l00251"></a>00251         }
<a name="l00252"></a>00252         <span class="keywordflow">return</span> Result;
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00261"></a><a class="code" href="namespace_bx_draw_global.html#a962033425c873ce7caa3eafc54426b1c">00261</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structvertexs.html" title="vertexs구조체 : count, {x, y, z}, ...">vertexs</a>&amp; <a class="code" href="namespace_bx_draw_global.html#a962033425c873ce7caa3eafc54426b1c" title="배열식 3D다각영역제작">XYZARRAY</a>(uint count, <span class="keywordtype">int</span>* xyz)
<a name="l00262"></a>00262     {
<a name="l00263"></a>00263         global_data <a class="code" href="structvertexs.html" title="vertexs구조체 : count, {x, y, z}, ...">vertexs</a> Result = {0,};
<a name="l00264"></a>00264         Result.count = count;
<a name="l00265"></a>00265         <span class="keywordflow">for</span>(uint i = 0; i &lt; count; ++i)
<a name="l00266"></a>00266         {
<a name="l00267"></a>00267             Result.vt[i].x = *(xyz++);
<a name="l00268"></a>00268             Result.vt[i].y = *(xyz++);
<a name="l00269"></a>00269             Result.vt[i].z = *(xyz++);
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271         <span class="keywordflow">return</span> Result;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00281"></a><a class="code" href="namespace_bx_draw_global.html#a6f404b715a4fced1ab3c989761f96d5f">00281</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_x888 <a class="code" href="namespace_bx_draw_global.html#a6f404b715a4fced1ab3c989761f96d5f" title="32비트 색상제작">RGB</a>(<span class="keyword">const</span> byte r, <span class="keyword">const</span> byte g, <span class="keyword">const</span> byte b)
<a name="l00282"></a>00282     {
<a name="l00283"></a>00283         <span class="keywordflow">return</span> ((r &amp; 0xFF) &lt;&lt; 16) | ((g &amp; 0xFF) &lt;&lt; 8) | (b &amp; 0xFF);
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 
<a name="l00293"></a><a class="code" href="namespace_bx_draw_global.html#a697f3baeaa375440107c563e28404f32">00293</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_565 <a class="code" href="namespace_bx_draw_global.html#a697f3baeaa375440107c563e28404f32" title="16비트 색상제작">RGB16</a>(<span class="keyword">const</span> byte r, <span class="keyword">const</span> byte g, <span class="keyword">const</span> byte b)
<a name="l00294"></a>00294     {
<a name="l00295"></a>00295         <span class="keywordflow">return</span> ((r &amp; 0xF8) &lt;&lt; 8) | ((g &amp; 0xFC) &lt;&lt; 3) | ((b &amp; 0xF8) &gt;&gt; 3);
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297 
<a name="l00305"></a><a class="code" href="namespace_bx_draw_global.html#a3af8af57551ff51e3584484517014b4c">00305</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_dst <a class="code" href="namespace_bx_draw_global.html#a3af8af57551ff51e3584484517014b4c" title="스프라이트 블렌딩">SpriteBlending</a>(<span class="keyword">const</span> pixel_dst dst, <span class="keyword">const</span> pixel_src src, <span class="keyword">const</span> byte* table)
<a name="l00306"></a>00306     {
<a name="l00307"></a>00307 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span>            <span class="keywordflow">return</span> table[(dst &gt;&gt; 6 &amp; 0x03E0) | (src &gt;&gt; 10 &amp; 0x001F)] &lt;&lt; 11
<a name="l00309"></a>00309                 | table[(dst &gt;&gt; 1 &amp; 0x03E0) | (src &gt;&gt; 5 &amp; 0x001F)] &lt;&lt; 6
<a name="l00310"></a>00310                 | table[(dst &lt;&lt; 5 &amp; 0x03E0) | (src &amp; 0x001F)];
<a name="l00311"></a>00311 <span class="preprocessor">        #else</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span>            <span class="keywordflow">return</span> table[(dst &gt;&gt; 8 &amp; 0xFF00) | (src &gt;&gt; 16 &amp; 0x00FF)] &lt;&lt; 16
<a name="l00313"></a>00313                 | table[(dst &amp; 0xFF00) | (src &gt;&gt; 8 &amp; 0x00FF)] &lt;&lt; 8
<a name="l00314"></a>00314                 | table[(dst &lt;&lt; 8 &amp; 0xFF00) | (src &amp; 0x00FF)];
<a name="l00315"></a>00315 <span class="preprocessor">        #endif</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>    }
<a name="l00317"></a>00317 
<a name="l00325"></a><a class="code" href="namespace_bx_draw_global.html#a2d833b80db8cc513b3a0dc3bb5cd0782">00325</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_dst <a class="code" href="namespace_bx_draw_global.html#a2d833b80db8cc513b3a0dc3bb5cd0782" title="알파 블렌딩">AlphaBlending</a>(<span class="keyword">const</span> pixel_dst dst, <span class="keyword">const</span> pixel_src src, <span class="keyword">const</span> byte* table)
<a name="l00326"></a>00326     {
<a name="l00327"></a>00327 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>            <span class="keywordflow">return</span> table[(src &gt;&gt; 3 &amp; 0x0E00) | (dst &gt;&gt; 7 &amp; 0x01F0) | (src &gt;&gt; 8 &amp; 0x000F)] &lt;&lt; 11
<a name="l00329"></a>00329                 | table[(src &gt;&gt; 3 &amp; 0x0E00) | (dst &gt;&gt; 2 &amp; 0x01F0) | (src &gt;&gt; 4 &amp; 0x000F)] &lt;&lt; 6
<a name="l00330"></a>00330                 | table[(src &gt;&gt; 3 &amp; 0x0E00) | (dst &lt;&lt; 4 &amp; 0x01F0) | (src &amp; 0x000F)];
<a name="l00331"></a>00331 <span class="preprocessor">        #else</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>            <span class="keywordflow">return</span> table[(src &gt;&gt; 13 &amp; 0x070000) | (dst &gt;&gt; 8 &amp; 0x00FF00) | (src &gt;&gt; 16 &amp; 0x0000FF)] &lt;&lt; 16
<a name="l00333"></a>00333                 | table[(src &gt;&gt; 13 &amp; 0x070000) | (dst &amp; 0x00FF00) | (src &gt;&gt; 8 &amp; 0x0000FF)] &lt;&lt; 8
<a name="l00334"></a>00334                 | table[(src &gt;&gt; 13 &amp; 0x070000) | (dst &lt;&lt; 8 &amp; 0x00FF00) | (src &amp; 0x0000FF)];
<a name="l00335"></a>00335 <span class="preprocessor">        #endif</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>    }
<a name="l00337"></a>00337 
<a name="l00343"></a><a class="code" href="namespace_bx_draw_global.html#a5626a4423f49d2a3c43d1a2b46180064">00343</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_m555_a444 <a class="code" href="namespace_bx_draw_global.html#a5626a4423f49d2a3c43d1a2b46180064" title="불투명도값 추출(M555_A444)">OpacityBitByM555A444</a>(<span class="keyword">const</span> color_m555_a444 color)
<a name="l00344"></a>00344     {
<a name="l00345"></a>00345         <span class="keywordflow">return</span> (color &amp; 0x8000)? 0x8000 : (color &amp; 0xF000);
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347 
<a name="l00353"></a><a class="code" href="namespace_bx_draw_global.html#a2a641bcd3364c262e79089d4eaaf2f80">00353</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_a888 <a class="code" href="namespace_bx_draw_global.html#a2a641bcd3364c262e79089d4eaaf2f80" title="불투명도값 추출(A888)">OpacityBitByA888</a>(<span class="keyword">const</span> color_a888 color)
<a name="l00354"></a>00354     {
<a name="l00355"></a>00355         <span class="keywordflow">return</span> 0xFF000000 &amp; color;
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357 
<a name="l00365"></a><a class="code" href="namespace_bx_draw_global.html#aed0fdc6eea4a4727834a7650ea945353">00365</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_x888 <a class="code" href="namespace_bx_draw_global.html#aed0fdc6eea4a4727834a7650ea945353" title="색상전환(RGB→HLS)">ColorRGBToHLS</a>(<span class="keyword">const</span> byte r, <span class="keyword">const</span> byte g, <span class="keyword">const</span> byte b)
<a name="l00366"></a>00366     {
<a name="l00367"></a>00367         <span class="keyword">const</span> <span class="keywordtype">int</span> MaxValue = (r &lt; g)? ((g &lt; b)? b : g) : ((r &lt; b)? b : r);
<a name="l00368"></a>00368         <span class="keyword">const</span> <span class="keywordtype">int</span> MinValue = (r &gt; g)? ((g &gt; b)? b : g) : ((r &gt; b)? b : r);
<a name="l00369"></a>00369         <span class="keyword">const</span> fint AddValue = (MaxValue + MinValue) &lt;&lt; 16;
<a name="l00370"></a>00370         <span class="keyword">const</span> fint SubValue = (MaxValue - MinValue) &lt;&lt; 16;
<a name="l00371"></a>00371         fint HValue = 0, LValue = AddValue / 510, SValue = 0;
<a name="l00372"></a>00372         <span class="keywordflow">if</span>(MaxValue != MinValue)
<a name="l00373"></a>00373         {
<a name="l00374"></a>00374             SValue = (fint) ((((huge) SubValue) &lt;&lt; 16) / ((LValue &lt;= 0x8000)? AddValue : (0x1FE0000 - AddValue)));
<a name="l00375"></a>00375             <span class="keyword">const</span> fint NormalR = (fint) (((MaxValue - (huge) r) &lt;&lt; 32) / SubValue);
<a name="l00376"></a>00376             <span class="keyword">const</span> fint NormalG = (fint) (((MaxValue - (huge) g) &lt;&lt; 32) / SubValue);
<a name="l00377"></a>00377             <span class="keyword">const</span> fint NormalB = (fint) (((MaxValue - (huge) b) &lt;&lt; 32) / SubValue);
<a name="l00378"></a>00378             <span class="keywordflow">if</span>(r == MaxValue) HValue = (42 * (0x60000 + NormalB - NormalG)) &amp; 0xFFFFFF;
<a name="l00379"></a>00379             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(g == MaxValue) HValue = (42 * (0x20000 + NormalR - NormalB)) &amp; 0xFFFFFF;
<a name="l00380"></a>00380             <span class="keywordflow">else</span> HValue = (42 * (0x40000 + NormalG - NormalR)) &amp; 0xFFFFFF;
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382         <span class="keywordflow">return</span> (((HValue &gt;&gt; 16) &amp; 0xFF) &lt;&lt; 16) | ((((LValue * 255) &gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8) | (((SValue * 255) &gt;&gt; 16) &amp; 0xFF);
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384 
<a name="l00392"></a><a class="code" href="namespace_bx_draw_global.html#a376b7e70661a03530504bcf0c80c9c58">00392</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_x888 <a class="code" href="namespace_bx_draw_global.html#a376b7e70661a03530504bcf0c80c9c58" title="색상전환(HLS→RGB)">ColorHLSToRGB</a>(<span class="keyword">const</span> byte h, <span class="keyword">const</span> byte l, <span class="keyword">const</span> byte s)
<a name="l00393"></a>00393     {
<a name="l00394"></a>00394         <span class="keywordflow">if</span>(0 &lt; s)
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396             <span class="keyword">const</span> fint HValue = (h &amp; 0xFF) &lt;&lt; 16, LValue = ((l &amp; 0xFF) &lt;&lt; 16) / 255, SValue = ((s &amp; 0xFF) &lt;&lt; 16) / 255;
<a name="l00397"></a>00397             <span class="keyword">const</span> fint XValue = LValue + (fint) ((LValue &lt;= 0x8000)? (LValue * (huge) SValue) &gt;&gt; 16 : SValue - ((LValue * (huge) SValue) &gt;&gt; 16));
<a name="l00398"></a>00398             <span class="keyword">const</span> fint YValue = 2 * LValue - XValue;
<a name="l00399"></a>00399             fint RValue = (HValue + 0x555555) &amp; 0xFFFFFF, GValue = HValue, BValue = (HValue + 0xAAAAAB) &amp; 0xFFFFFF;
<a name="l00400"></a>00400             <span class="keywordflow">if</span>(RValue &lt; 0x2A0000) RValue = YValue + (((XValue - YValue) * (huge) RValue) &gt;&gt; 16) / 42;
<a name="l00401"></a>00401             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(RValue &lt; 0x800000) RValue = XValue;
<a name="l00402"></a>00402             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(RValue &lt; 0xAAAAAA) RValue = YValue + (((XValue - YValue) * (huge) (0xAAAAAA - RValue)) &gt;&gt; 16) / 42;
<a name="l00403"></a>00403             <span class="keywordflow">else</span> RValue = YValue;
<a name="l00404"></a>00404             <span class="keywordflow">if</span>(GValue &lt; 0x2A0000) GValue = YValue + (((XValue - YValue) * (huge) GValue) &gt;&gt; 16) / 42;
<a name="l00405"></a>00405             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(GValue &lt; 0x800000) GValue = XValue;
<a name="l00406"></a>00406             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(GValue &lt; 0xAAAAAA) GValue = YValue + (((XValue - YValue) * (huge) (0xAAAAAA - GValue)) &gt;&gt; 16) / 42;
<a name="l00407"></a>00407             <span class="keywordflow">else</span> GValue = YValue;
<a name="l00408"></a>00408             <span class="keywordflow">if</span>(BValue &lt; 0x2A0000) BValue = YValue + (((XValue - YValue) * (huge) BValue) &gt;&gt; 16) / 42;
<a name="l00409"></a>00409             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(BValue &lt; 0x800000) BValue = XValue;
<a name="l00410"></a>00410             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(BValue &lt; 0xAAAAAA) BValue = YValue + (((XValue - YValue) * (huge) (0xAAAAAA - BValue)) &gt;&gt; 16) / 42;
<a name="l00411"></a>00411             <span class="keywordflow">else</span> BValue = YValue;
<a name="l00412"></a>00412             <span class="keywordflow">return</span> ((((RValue * 255 + 0x8000) &gt;&gt; 16) &amp; 0xFF) &lt;&lt; 16) | ((((GValue * 255 + 0x8000) &gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8) | (((BValue * 255 + 0x8000) &gt;&gt; 16) &amp; 0xFF);
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414         <span class="keywordflow">return</span> ((l &amp; 0xFF) &lt;&lt; 16) | ((l &amp; 0xFF) &lt;&lt; 8) | (l &amp; 0xFF);
<a name="l00415"></a>00415     }
<a name="l00416"></a>00416 
<a name="l00422"></a><a class="code" href="namespace_bx_draw_global.html#a3abdbd52000a7c19b9d768ecf271faaa">00422</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_565 <a class="code" href="namespace_bx_draw_global.html#a3abdbd52000a7c19b9d768ecf271faaa" title="색상전환(M555_A444→565)">ColorM555A444To565</a>(<span class="keyword">const</span> color_m555_a444 color)
<a name="l00423"></a>00423     {
<a name="l00424"></a>00424         <span class="keywordflow">return</span> (color &amp; 0x8000)? ((color &lt;&lt; 1) &amp; 0xFFC0) | ((color &gt;&gt; 4) &amp; 0x0020) | (color &amp; 0x001F)
<a name="l00425"></a>00425             : ((color &lt;&lt; 4) &amp; 0xF000) | ((color &gt;&gt; 0) &amp; 0x0800)
<a name="l00426"></a>00426             | ((color &lt;&lt; 3) &amp; 0x0780) | ((color &gt;&gt; 1) &amp; 0x0060)
<a name="l00427"></a>00427             | ((color &lt;&lt; 1) &amp; 0x001E) | ((color &gt;&gt; 3) &amp; 0x0001);
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429 
<a name="l00435"></a><a class="code" href="namespace_bx_draw_global.html#a6ddc89338e2f260ae27546f3f9fcac12">00435</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_a888 <a class="code" href="namespace_bx_draw_global.html#a6ddc89338e2f260ae27546f3f9fcac12" title="색상전환(M555_A444→A888)">ColorM555A444ToA888</a>(<span class="keyword">const</span> color_m555_a444 color)
<a name="l00436"></a>00436     {
<a name="l00437"></a>00437         <span class="keyword">const</span> color_565 c = <a class="code" href="namespace_bx_draw_global.html#a3abdbd52000a7c19b9d768ecf271faaa" title="색상전환(M555_A444→565)">ColorM555A444To565</a>(color);
<a name="l00438"></a>00438         <span class="keyword">const</span> color_m555_a444 o = <a class="code" href="namespace_bx_draw_global.html#a5626a4423f49d2a3c43d1a2b46180064" title="불투명도값 추출(M555_A444)">OpacityBitByM555A444</a>(color);
<a name="l00439"></a>00439         <span class="keywordflow">return</span> ((o == 0x8000)? 0xFF000000 : (((o &amp; 0xF000) &lt;&lt; 16) | ((o &amp; 0xF000) &lt;&lt; 12))) |
<a name="l00440"></a>00440             ((c &lt;&lt; 8) &amp; 0xF80000) | ((c &lt;&lt; 3) &amp; 0x070000) |
<a name="l00441"></a>00441             ((c &lt;&lt; 5) &amp; 0x00FC00) | ((c &gt;&gt; 1) &amp; 0x000300) |
<a name="l00442"></a>00442             ((c &lt;&lt; 3) &amp; 0x0000F8) | ((c &gt;&gt; 2) &amp; 0x000007);
<a name="l00443"></a>00443     }
<a name="l00444"></a>00444 
<a name="l00450"></a><a class="code" href="namespace_bx_draw_global.html#ace2e54d6e9f621e8800cda0be12e8e8e">00450</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> color_x888 <a class="code" href="namespace_bx_draw_global.html#ace2e54d6e9f621e8800cda0be12e8e8e" title="색상전환(A888→X888)">ColorA888ToX888</a>(<span class="keyword">const</span> color_a888 color)
<a name="l00451"></a>00451     {
<a name="l00452"></a>00452         <span class="keywordflow">return</span> 0x00FFFFFF &amp; color;
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00460"></a><a class="code" href="namespace_bx_draw_global.html#acdda0ad3e9387274a1fbc9aa6210b757">00460</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_dst <a class="code" href="namespace_bx_draw_global.html#acdda0ad3e9387274a1fbc9aa6210b757" title="네이티브바탕으로 색상전환(565→NativeDst)">Color565ToNativeDst</a>(<span class="keyword">const</span> color_565 color)
<a name="l00461"></a>00461     {
<a name="l00462"></a>00462 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>            <span class="keywordflow">return</span> color;
<a name="l00464"></a>00464 <span class="preprocessor">        #else</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((color &lt;&lt; 8) &amp; 0xF80000) | ((color &lt;&lt; 3) &amp; 0x070000) |
<a name="l00466"></a>00466                 ((color &lt;&lt; 5) &amp; 0x00FC00) | ((color &gt;&gt; 1) &amp; 0x000300) |
<a name="l00467"></a>00467                 ((color &lt;&lt; 3) &amp; 0x0000F8) | ((color &gt;&gt; 2) &amp; 0x000007);
<a name="l00468"></a>00468 <span class="preprocessor">        #endif</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span>    }
<a name="l00470"></a>00470 
<a name="l00476"></a><a class="code" href="namespace_bx_draw_global.html#a6ad7cb2fb717655bb122e55879f5757d">00476</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_src <a class="code" href="namespace_bx_draw_global.html#a6ad7cb2fb717655bb122e55879f5757d" title="네이티브소스로 색상전환(565→NativeSrc)">Color565ToNativeSrc</a>(<span class="keyword">const</span> color_565 color, <span class="keyword">const</span> color_m555_a444 opacity_bit = 0x8000)
<a name="l00477"></a>00477     {
<a name="l00478"></a>00478 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>            <span class="keywordflow">return</span> (opacity_bit == 0x8000)?
<a name="l00480"></a>00480                 opacity_bit | ((color &gt;&gt; 1) &amp; 0x7FE0) | (color &amp; 0x001F)
<a name="l00481"></a>00481                 : opacity_bit | ((color &gt;&gt; 4) &amp; 0x0F00) | ((color &gt;&gt; 3) &amp; 0x00F0) | ((color &gt;&gt; 1) &amp; 0x000F);
<a name="l00482"></a>00482 <span class="preprocessor">        #else</span>
<a name="l00483"></a>00483 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((opacity_bit == 0x8000)? 0xFF000000 : (((opacity_bit &amp; 0xF000) &lt;&lt; 16) | ((opacity_bit &amp; 0xF000) &lt;&lt; 12))) |
<a name="l00484"></a>00484                 ((color &lt;&lt; 8) &amp; 0xF80000) | ((color &lt;&lt; 3) &amp; 0x070000) |
<a name="l00485"></a>00485                 ((color &lt;&lt; 5) &amp; 0x00FC00) | ((color &gt;&gt; 1) &amp; 0x000300) |
<a name="l00486"></a>00486                 ((color &lt;&lt; 3) &amp; 0x0000F8) | ((color &gt;&gt; 2) &amp; 0x000007);
<a name="l00487"></a>00487 <span class="preprocessor">        #endif</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span>    }
<a name="l00489"></a>00489 
<a name="l00495"></a><a class="code" href="namespace_bx_draw_global.html#acf4ac9a6456284e2939026cba3c4fc4e">00495</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_dst <a class="code" href="namespace_bx_draw_global.html#acf4ac9a6456284e2939026cba3c4fc4e" title="네이티브바탕으로 색상전환(M555_A444→NativeDst)">ColorM555A444ToNativeDst</a>(<span class="keyword">const</span> color_m555_a444 color)
<a name="l00496"></a>00496     {
<a name="l00497"></a>00497         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#acdda0ad3e9387274a1fbc9aa6210b757" title="네이티브바탕으로 색상전환(565→NativeDst)">Color565ToNativeDst</a>(<a class="code" href="namespace_bx_draw_global.html#a3abdbd52000a7c19b9d768ecf271faaa" title="색상전환(M555_A444→565)">ColorM555A444To565</a>(color));
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 
<a name="l00505"></a><a class="code" href="namespace_bx_draw_global.html#a47cfb9289b6e1376c1c6667a080e0d31">00505</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_src <a class="code" href="namespace_bx_draw_global.html#a47cfb9289b6e1376c1c6667a080e0d31" title="네이티브소스로 색상전환(M555_A444→NativeSrc)">ColorM555A444ToNativeSrc</a>(<span class="keyword">const</span> color_m555_a444 color)
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#a6ad7cb2fb717655bb122e55879f5757d" title="네이티브소스로 색상전환(565→NativeSrc)">Color565ToNativeSrc</a>(<a class="code" href="namespace_bx_draw_global.html#a3abdbd52000a7c19b9d768ecf271faaa" title="색상전환(M555_A444→565)">ColorM555A444To565</a>(color), <a class="code" href="namespace_bx_draw_global.html#a5626a4423f49d2a3c43d1a2b46180064" title="불투명도값 추출(M555_A444)">OpacityBitByM555A444</a>(color));
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 
<a name="l00515"></a><a class="code" href="namespace_bx_draw_global.html#a4c30e61d070179051cba5452644d2b87">00515</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_dst <a class="code" href="namespace_bx_draw_global.html#a4c30e61d070179051cba5452644d2b87" title="네이티브바탕으로 색상전환(X888→NativeDst)">ColorX888ToNativeDst</a>(<span class="keyword">const</span> color_x888 color)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((color &gt;&gt; 8) &amp; 0xF800) | ((color &gt;&gt; 5) &amp; 0x07E0) | ((color &gt;&gt; 3) &amp; 0x001F);
<a name="l00519"></a>00519 <span class="preprocessor">        #else</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>            <span class="keywordflow">return</span> color;
<a name="l00521"></a>00521 <span class="preprocessor">        #endif</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span>    }
<a name="l00523"></a>00523 
<a name="l00529"></a><a class="code" href="namespace_bx_draw_global.html#a3dc452d155a051598cf0038062a2a7d8">00529</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_src <a class="code" href="namespace_bx_draw_global.html#a3dc452d155a051598cf0038062a2a7d8" title="네이티브소스로 색상전환(X888→NativeSrc)">ColorX888ToNativeSrc</a>(<span class="keyword">const</span> color_x888 color, <span class="keyword">const</span> color_a888 opacity_bit = 0xFF000000)
<a name="l00530"></a>00530     {
<a name="l00531"></a>00531 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span>            <span class="keywordflow">return</span> (opacity_bit == 0xFF000000)?
<a name="l00533"></a>00533                 0x8000 | ((color &gt;&gt; 9) &amp; 0x7C00) | ((color &gt;&gt; 6) &amp; 0x03E0) | ((color &gt;&gt; 3) &amp; 0x001F)
<a name="l00534"></a>00534                 : ((opacity_bit &gt;&gt; 17) &amp; 0x7000) | ((color &gt;&gt; 12) &amp; 0x0F00) | ((color &gt;&gt; 8) &amp; 0x00F0) | ((color &gt;&gt; 4) &amp; 0x000F);
<a name="l00535"></a>00535 <span class="preprocessor">        #else</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span>            <span class="keywordflow">return</span> opacity_bit | color;
<a name="l00537"></a>00537 <span class="preprocessor">        #endif</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span>    }
<a name="l00539"></a>00539 
<a name="l00545"></a><a class="code" href="namespace_bx_draw_global.html#aa908d2a442879cd385e3f2028cf23d30">00545</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_dst <a class="code" href="namespace_bx_draw_global.html#aa908d2a442879cd385e3f2028cf23d30" title="네이티브바탕으로 색상전환(A888→NativeDst)">ColorA888ToNativeDst</a>(<span class="keyword">const</span> color_a888 color)
<a name="l00546"></a>00546     {
<a name="l00547"></a>00547         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#a4c30e61d070179051cba5452644d2b87" title="네이티브바탕으로 색상전환(X888→NativeDst)">ColorX888ToNativeDst</a>(<a class="code" href="namespace_bx_draw_global.html#ace2e54d6e9f621e8800cda0be12e8e8e" title="색상전환(A888→X888)">ColorA888ToX888</a>(color));
<a name="l00548"></a>00548     }
<a name="l00549"></a>00549 
<a name="l00555"></a><a class="code" href="namespace_bx_draw_global.html#afa4322bd48d4974dd6f9f8cf7b9e44bb">00555</a>     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> pixel_src <a class="code" href="namespace_bx_draw_global.html#afa4322bd48d4974dd6f9f8cf7b9e44bb" title="네이티브소스로 색상전환(A888→NativeSrc)">ColorA888ToNativeSrc</a>(<span class="keyword">const</span> color_a888 color)
<a name="l00556"></a>00556     {
<a name="l00557"></a>00557         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#a3dc452d155a051598cf0038062a2a7d8" title="네이티브소스로 색상전환(X888→NativeSrc)">ColorX888ToNativeSrc</a>(<a class="code" href="namespace_bx_draw_global.html#ace2e54d6e9f621e8800cda0be12e8e8e" title="색상전환(A888→X888)">ColorA888ToX888</a>(color), <a class="code" href="namespace_bx_draw_global.html#a2a641bcd3364c262e79089d4eaaf2f80" title="불투명도값 추출(A888)">OpacityBitByA888</a>(color));
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559 
<a name="l00561"></a>00561     <span class="comment">// 옵션관리</span>
<a name="l00562"></a>00562     <span class="keyword">class </span>_DrawOption
<a name="l00563"></a>00563     {
<a name="l00564"></a>00564     <span class="keyword">public</span>:
<a name="l00565"></a>00565         <span class="comment">// 테이블링</span>
<a name="l00566"></a>00566         global_func <span class="keyword">inline</span> uint GetBlend(<span class="keyword">const</span> drawblend blend, <span class="keyword">const</span> uint dst, <span class="keyword">const</span> uint src, <span class="keyword">const</span> uint indexMax)
<a name="l00567"></a>00567         {
<a name="l00568"></a>00568             <span class="keyword">const</span> uint fullLen = indexMax + 1, halfLen = fullLen / 2;
<a name="l00569"></a>00569             <span class="keywordflow">switch</span>(blend)
<a name="l00570"></a>00570             {
<a name="l00571"></a>00571             <span class="keywordflow">case</span> blend_normal: <span class="keywordflow">return</span> src;
<a name="l00572"></a>00572             <span class="keywordflow">case</span> blend_darken: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(dst, src);
<a name="l00573"></a>00573             <span class="keywordflow">case</span> blend_lighten: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(dst, src);
<a name="l00574"></a>00574             <span class="keywordflow">case</span> blend_multiply: <span class="keywordflow">return</span> (dst * src) / indexMax;
<a name="l00575"></a>00575             <span class="keywordflow">case</span> blend_screen: <span class="keywordflow">return</span> indexMax - ((indexMax - dst) * (indexMax - src) / indexMax);
<a name="l00576"></a>00576             <span class="keywordflow">case</span> blend_color_dodge: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(indexMax, (dst * indexMax) / (fullLen - src));
<a name="l00577"></a>00577             <span class="keywordflow">case</span> blend_color_burn: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(0, indexMax - (indexMax - dst) * indexMax / <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, src));
<a name="l00578"></a>00578             <span class="keywordflow">case</span> blend_linear_dodge: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(dst + src, indexMax);
<a name="l00579"></a>00579             <span class="keywordflow">case</span> blend_linear_burn: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(0, dst + src - indexMax);
<a name="l00580"></a>00580             <span class="keywordflow">case</span> blend_linear_light: <span class="keywordflow">return</span> dst + src * 2 - indexMax;
<a name="l00581"></a>00581             <span class="keywordflow">case</span> blend_overlay: <span class="keywordflow">return</span> (dst &lt; halfLen)? <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(indexMax, src * dst * 2 / indexMax) : BxUtilGlobal::Max(0, indexMax - (indexMax - src) * (indexMax - dst) * 2 / indexMax);
<a name="l00582"></a>00582             <span class="keywordflow">case</span> blend_hard_light: <span class="keywordflow">return</span> (halfLen &lt; src)? <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(0, indexMax - (indexMax - src) * (indexMax - dst) * 2 / indexMax) : BxUtilGlobal::Min(indexMax, src * dst * 2 / indexMax);
<a name="l00583"></a>00583             <span class="keywordflow">case</span> blend_pin_light: <span class="keywordflow">return</span> (dst &lt; (src &lt;&lt; 1) - indexMax)? <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(0, (src &lt;&lt; 1) - indexMax) : (((src &lt;&lt; 1) - indexMax &lt; dst &amp;&amp; dst &lt; (src &lt;&lt; 1))? dst : BxUtilGlobal::Min(indexMax, src &lt;&lt; 1));
<a name="l00584"></a>00584             <span class="keywordflow">case</span> blend_hard_mix: <span class="keywordflow">return</span> (src &lt; indexMax - dst)? 0 : indexMax;
<a name="l00585"></a>00585             <span class="keywordflow">case</span> blend_defferent: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(src, dst) - <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(src, dst);
<a name="l00586"></a>00586             <span class="keywordflow">case</span> blend_exclusion: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(0, <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(indexMax, src + dst - src * dst * 2 / indexMax));
<a name="l00587"></a>00587             <span class="keywordflow">case</span> blend_gray: <span class="keywordflow">return</span> 0;
<a name="l00588"></a>00588             <span class="keywordflow">case</span> blend_add: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(dst + src, indexMax);
<a name="l00589"></a>00589             <span class="keywordflow">case</span> blend_sub: <span class="keywordflow">return</span> <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(0, src - dst);
<a name="l00590"></a>00590             <span class="keywordflow">case</span> blend_xor: <span class="keywordflow">return</span> src ^ dst;
<a name="l00591"></a>00591             }
<a name="l00592"></a>00592             <span class="keywordflow">return</span> 0;
<a name="l00593"></a>00593         }
<a name="l00594"></a>00594 <span class="preprocessor">        #ifndef __BX_OPENGL</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span>        global_func byte* GetSpriteTable(drawblend blend)
<a name="l00596"></a>00596         {
<a name="l00597"></a>00597             global_data byte* Table[blend_max] = {null,};
<a name="l00598"></a>00598             <span class="keywordflow">if</span>(!Table[blend])
<a name="l00599"></a>00599             {
<a name="l00600"></a>00600 <span class="preprocessor">                #ifdef __BX_PIXEL16</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span>                    Table[blend] = BxNew_Array(byte, 8 * 32 * 32);
<a name="l00602"></a>00602                     <span class="keywordflow">for</span>(uint opa = 0; opa &lt; 8; ++opa)
<a name="l00603"></a>00603                     <span class="keywordflow">for</span>(uint dst = 0; dst &lt; 32; ++dst)
<a name="l00604"></a>00604                     <span class="keywordflow">for</span>(uint src = 0; src &lt; 32; ++src)
<a name="l00605"></a>00605                     {
<a name="l00606"></a>00606                         <span class="keyword">const</span> uint BlendedSrc = GetBlend(blend, dst, src, 0x1F);
<a name="l00607"></a>00607                         Table[blend][(opa &lt;&lt; 10) | (dst &lt;&lt; 5) | src] =
<a name="l00608"></a>00608                             ((dst * (7 - opa)) + (BlendedSrc * (1 + opa))) / 8;
<a name="l00609"></a>00609                     }
<a name="l00610"></a>00610 <span class="preprocessor">                #else</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>                    Table[blend] = BxNew_Array(byte, 8 * 256 * 256);
<a name="l00612"></a>00612                     <span class="keywordflow">for</span>(uint opa = 0; opa &lt; 8; ++opa)
<a name="l00613"></a>00613                     <span class="keywordflow">for</span>(uint dst = 0; dst &lt; 256; ++dst)
<a name="l00614"></a>00614                     <span class="keywordflow">for</span>(uint src = 0; src &lt; 256; ++src)
<a name="l00615"></a>00615                     {
<a name="l00616"></a>00616                         <span class="keyword">const</span> uint BlendedSrc = GetBlend(blend, dst, src, 0xFF);
<a name="l00617"></a>00617                         Table[blend][(opa &lt;&lt; 16) | (dst &lt;&lt; 8) | src] =
<a name="l00618"></a>00618                             ((dst * (7 - opa)) + (BlendedSrc * (1 + opa))) / 8;
<a name="l00619"></a>00619                     }
<a name="l00620"></a>00620 <span class="preprocessor">                #endif</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>            }
<a name="l00622"></a>00622             <span class="keywordflow">return</span> Table[blend];
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624         global_func byte* GetAlphaTable(drawblend blend)
<a name="l00625"></a>00625         {
<a name="l00626"></a>00626             global_data byte* Table[blend_max] = {null,};
<a name="l00627"></a>00627             <span class="keywordflow">if</span>(!Table[blend])
<a name="l00628"></a>00628             {
<a name="l00629"></a>00629 <span class="preprocessor">                #ifdef __BX_PIXEL16</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span>                    Table[blend] = BxNew_Array(byte, 8 * 8 * 32 * 16);
<a name="l00631"></a>00631                     <span class="keywordflow">for</span>(uint opa = 0; opa &lt; 8; ++opa)
<a name="l00632"></a>00632                     <span class="keywordflow">for</span>(uint src_opa = 0; src_opa &lt; 8; ++src_opa)
<a name="l00633"></a>00633                     <span class="keywordflow">for</span>(uint dst = 0; dst &lt; 32; ++dst)
<a name="l00634"></a>00634                     <span class="keywordflow">for</span>(uint src = 0; src &lt; 16; ++src)
<a name="l00635"></a>00635                     {
<a name="l00636"></a>00636                         <span class="keyword">const</span> uint BlendedSrc = GetBlend(blend, dst, (src &lt;&lt; 1) | (src &gt;&gt; 3), 0x1F);
<a name="l00637"></a>00637                         <span class="keyword">const</span> uint BlendedSrc2 = (dst * (7 - opa)) + (BlendedSrc * (1 + opa));
<a name="l00638"></a>00638                         Table[blend][(opa &lt;&lt; 12) | (src_opa &lt;&lt; 9) | (dst &lt;&lt; 4) | src] =
<a name="l00639"></a>00639                             ((dst * (8 - src_opa) * 8) + (BlendedSrc2 * src_opa)) / (8 * 8);
<a name="l00640"></a>00640                     }
<a name="l00641"></a>00641 <span class="preprocessor">                #else</span>
<a name="l00642"></a>00642 <span class="preprocessor"></span>                    Table[blend] = BxNew_Array(byte, 8 * 8 * 256 * 256);
<a name="l00643"></a>00643                     <span class="keywordflow">for</span>(uint opa = 0; opa &lt; 8; ++opa)
<a name="l00644"></a>00644                     <span class="keywordflow">for</span>(uint src_opa = 0; src_opa &lt; 8; ++src_opa)
<a name="l00645"></a>00645                     <span class="keywordflow">for</span>(uint dst = 0; dst &lt; 256; ++dst)
<a name="l00646"></a>00646                     <span class="keywordflow">for</span>(uint src = 0; src &lt; 256; ++src)
<a name="l00647"></a>00647                     {
<a name="l00648"></a>00648                         <span class="keyword">const</span> uint BlendedSrc = GetBlend(blend, dst, src, 0xFF);
<a name="l00649"></a>00649                         <span class="keyword">const</span> uint BlendedSrc2 = (dst * (7 - opa)) + (BlendedSrc * (1 + opa));
<a name="l00650"></a>00650                         Table[blend][(opa &lt;&lt; 19) | (src_opa &lt;&lt; 16) | (dst &lt;&lt; 8) | src] =
<a name="l00651"></a>00651                             ((dst * (8 - src_opa) * 8) + (BlendedSrc2 * src_opa)) / (8 * 8);
<a name="l00652"></a>00652                     }
<a name="l00653"></a>00653 <span class="preprocessor">                #endif</span>
<a name="l00654"></a>00654 <span class="preprocessor"></span>            }
<a name="l00655"></a>00655             <span class="keywordflow">return</span> Table[blend];
<a name="l00656"></a>00656         }
<a name="l00657"></a>00657 <span class="preprocessor">        #endif</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span>        <span class="comment">// 현재스타일</span>
<a name="l00659"></a>00659         global_func <span class="keyword">inline</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a>&amp; CurClipRect() {global_data <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> ClipRect; <span class="keywordflow">return</span> ClipRect;}
<a name="l00660"></a>00660         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurHotspotX() {global_data <span class="keywordtype">int</span> HotspotX; <span class="keywordflow">return</span> HotspotX;}
<a name="l00661"></a>00661         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurHotspotY() {global_data <span class="keywordtype">int</span> HotspotY; <span class="keywordflow">return</span> HotspotY;}
<a name="l00662"></a>00662         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurAreaWidth() {global_data <span class="keywordtype">int</span> AreaWidth; <span class="keywordflow">return</span> AreaWidth;}
<a name="l00663"></a>00663         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurAreaHeight() {global_data <span class="keywordtype">int</span> AreaHeight; <span class="keywordflow">return</span> AreaHeight;}
<a name="l00664"></a>00664         global_func <span class="keyword">inline</span> maskoperate&amp; CurMaskOperate() {global_data maskoperate Operate; <span class="keywordflow">return</span> Operate;}
<a name="l00665"></a>00665         global_func <span class="keyword">inline</span> maskflag&amp; CurMaskFlag() {global_data maskflag Flag; <span class="keywordflow">return</span> Flag;}
<a name="l00666"></a>00666         global_func <span class="keyword">inline</span> drawturn&amp; CurTurn() {global_data drawturn Turn; <span class="keywordflow">return</span> Turn;}
<a name="l00667"></a>00667         global_func <span class="keyword">inline</span> byte&amp; CurAngle() {global_data byte Angle; <span class="keywordflow">return</span> Angle;}
<a name="l00668"></a>00668         global_func <span class="keyword">inline</span> fint&amp; CurScaleHor() {global_data fint ScaleHor; <span class="keywordflow">return</span> ScaleHor;}
<a name="l00669"></a>00669         global_func <span class="keyword">inline</span> fint&amp; CurScaleVer() {global_data fint ScaleVer; <span class="keywordflow">return</span> ScaleVer;}
<a name="l00670"></a>00670         global_func <span class="keyword">inline</span> color_x888&amp; CurColor() {global_data color_x888 Color; <span class="keywordflow">return</span> Color;}
<a name="l00671"></a>00671         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurOpacity7() {global_data <span class="keywordtype">int</span> Opacity7; <span class="keywordflow">return</span> Opacity7;} <span class="comment">// -1:0%, 0:12.5%, 6:87.5%, 7:100%</span>
<a name="l00672"></a>00672         global_func <span class="keyword">inline</span> drawblend&amp; CurBlend() {global_data drawblend Blend; <span class="keywordflow">return</span> Blend;}
<a name="l00673"></a>00673 <span class="preprocessor">        #ifndef __BX_OPENGL</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>        global_func <span class="keyword">inline</span> byte*&amp; CurSpriteTable() {global_data byte* Table; <span class="keywordflow">return</span> Table;}
<a name="l00675"></a>00675         global_func <span class="keyword">inline</span> byte*&amp; CurAlphaTable() {global_data byte* Table; <span class="keywordflow">return</span> Table;}
<a name="l00676"></a>00676 <span class="preprocessor">        #endif</span>
<a name="l00677"></a>00677 <span class="preprocessor"></span>        global_func <span class="keyword">inline</span> <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>*&amp; CurForm() {global_data <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>* Form; <span class="keywordflow">return</span> Form;}
<a name="l00678"></a>00678         global_func <span class="keyword">inline</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a>&amp; CurFormRect() {global_data <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> FormRect; <span class="keywordflow">return</span> FormRect;}
<a name="l00679"></a>00679         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurMoveX3D() {global_data <span class="keywordtype">int</span> MoveX3D; <span class="keywordflow">return</span> MoveX3D;}
<a name="l00680"></a>00680         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurMoveY3D() {global_data <span class="keywordtype">int</span> MoveY3D; <span class="keywordflow">return</span> MoveY3D;}
<a name="l00681"></a>00681         global_func <span class="keyword">inline</span> <span class="keywordtype">int</span>&amp; CurMoveZ3D() {global_data <span class="keywordtype">int</span> MoveZ3D; <span class="keywordflow">return</span> MoveZ3D;}
<a name="l00682"></a>00682     };
<a name="l00684"></a>00684 
<a name="l00686"></a>00686     <span class="comment">// 디폴트 폼클래스</span>
<a name="l00687"></a>00687     <span class="keyword">class </span>_BxColorMap : <span class="keyword">public</span> <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689     <span class="keyword">public</span>:
<a name="l00690"></a>00690         global_func <span class="keyword">inline</span> _BxColorMap* GetClass() {global_data _BxColorMap Class; <span class="keywordflow">return</span> &amp;Class;}
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     <span class="keyword">protected</span>:
<a name="l00693"></a>00693         _BxColorMap()
<a name="l00694"></a>00694         {
<a name="l00695"></a>00695             Area.w = 16;
<a name="l00696"></a>00696             Area.h = 16;
<a name="l00697"></a>00697             Area.hx = 8;
<a name="l00698"></a>00698             Area.hy = 8;
<a name="l00699"></a>00699         }
<a name="l00700"></a>00700         <span class="keyword">virtual</span> ~_BxColorMap() {}
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     <span class="keyword">public</span>:
<a name="l00703"></a>00703         <span class="keyword">virtual</span> OnFormMethod GetFormMethod(maskoperate operate, maskflag flag)
<a name="l00704"></a>00704         {
<a name="l00705"></a>00705             <span class="keywordflow">switch</span>(operate)
<a name="l00706"></a>00706             {
<a name="l00707"></a>00707             <span class="keywordflow">case</span> maskoperate_all_print:
<a name="l00708"></a>00708                 <span class="keywordflow">if</span>(flag == maskflag_no_write)
<a name="l00709"></a>00709                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_all_print, maskflag_no_write&gt;;
<a name="l00710"></a>00710                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == maskflag_write_1)
<a name="l00711"></a>00711                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_all_print, maskflag_write_1&gt;;
<a name="l00712"></a>00712                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == maskflag_write_0)
<a name="l00713"></a>00713                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_all_print, maskflag_write_0&gt;;
<a name="l00714"></a>00714                 <span class="keywordflow">break</span>;
<a name="l00715"></a>00715             <span class="keywordflow">case</span> maskoperate_no_print:
<a name="l00716"></a>00716                 <span class="keywordflow">return</span> OnFormNoPrint;
<a name="l00717"></a>00717             <span class="keywordflow">case</span> maskoperate_print_by_1:
<a name="l00718"></a>00718                 <span class="keywordflow">if</span>(flag == maskflag_no_write)
<a name="l00719"></a>00719                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_print_by_1, maskflag_no_write&gt;;
<a name="l00720"></a>00720                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == maskflag_write_1)
<a name="l00721"></a>00721                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_print_by_1, maskflag_write_1&gt;;
<a name="l00722"></a>00722                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == maskflag_write_0)
<a name="l00723"></a>00723                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_print_by_1, maskflag_write_0&gt;;
<a name="l00724"></a>00724                 <span class="keywordflow">break</span>;
<a name="l00725"></a>00725             <span class="keywordflow">case</span> maskoperate_print_by_0:
<a name="l00726"></a>00726                 <span class="keywordflow">if</span>(flag == maskflag_no_write)
<a name="l00727"></a>00727                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_print_by_0, maskflag_no_write&gt;;
<a name="l00728"></a>00728                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == maskflag_write_1)
<a name="l00729"></a>00729                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_print_by_0, maskflag_write_1&gt;;
<a name="l00730"></a>00730                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(flag == maskflag_write_0)
<a name="l00731"></a>00731                     <span class="keywordflow">return</span> OnForm&lt;maskoperate_print_by_0, maskflag_write_0&gt;;
<a name="l00732"></a>00732                 <span class="keywordflow">break</span>;
<a name="l00733"></a>00733             }
<a name="l00734"></a>00734             <span class="keywordflow">return</span> null;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="keyword">protected</span>:
<a name="l00738"></a>00738         <span class="keyword">template</span>&lt;maskoperate MASKOP, maskflag MASK&gt;
<a name="l00739"></a>00739         global_func <span class="keywordtype">void</span> OnForm(<a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp; srcClass, <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> srcRect, pixel_dst* rowBuffer, <span class="keyword">const</span> uint rowLength,
<a name="l00740"></a>00740             <span class="keyword">const</span> fint x, <span class="keyword">const</span> fint y, <span class="keyword">const</span> fint xVec, <span class="keyword">const</span> fint yVec, <span class="keyword">const</span> byte* blendSpriteTable, <span class="keyword">const</span> byte* blendAlphaTable)
<a name="l00741"></a>00741         {
<a name="l00742"></a>00742             <span class="keyword">const</span> pixel_dst* RowBufferEnd = rowBuffer + rowLength;
<a name="l00743"></a>00743             <span class="keywordflow">if</span>(_DrawOption::CurOpacity7() == 7 &amp;&amp; _DrawOption::CurBlend() == blend_normal)
<a name="l00744"></a>00744             {
<a name="l00745"></a>00745                 <span class="keyword">const</span> pixel_dst Color = <a class="code" href="namespace_bx_draw_global.html#a4c30e61d070179051cba5452644d2b87" title="네이티브바탕으로 색상전환(X888→NativeDst)">BxDrawGlobal::ColorX888ToNativeDst</a>(_DrawOption::CurColor());
<a name="l00746"></a>00746                 <span class="keywordflow">switch</span>(~(rowLength - 1) &amp; 0x3F)
<a name="l00747"></a>00747                 <span class="keywordflow">while</span>(rowBuffer &lt; RowBufferEnd)
<a name="l00748"></a>00748                     CASE64(\
<a name="l00749"></a>00749                     <span class="keywordflow">if</span>(MASKOP == maskoperate_all_print || (MASKOP == maskoperate_print_by_1 &amp;&amp; (*rowBuffer &amp; _MASK_BIT_)) || (MASKOP == maskoperate_print_by_0 &amp;&amp; (~*rowBuffer &amp; _MASK_BIT_)))\
<a name="l00750"></a>00750                     {\
<a name="l00751"></a>00751                         *rowBuffer = Color;\
<a name="l00752"></a>00752                         if(<a class="code" href="namespace_bx_draw_global.html#a4cb0b256ca23670eb23ac466be2fcb42" title="스타일-마스크">MASK</a> == maskflag_write_1) *rowBuffer |= _MASK_BIT_;\
<a name="l00753"></a>00753                         if(<a class="code" href="namespace_bx_draw_global.html#a4cb0b256ca23670eb23ac466be2fcb42" title="스타일-마스크">MASK</a> == maskflag_write_0) *rowBuffer &amp;= ~_MASK_BIT_;\
<a name="l00754"></a>00754                     }\
<a name="l00755"></a>00755                     ++rowBuffer;)
<a name="l00756"></a>00756             }
<a name="l00757"></a>00757             <span class="keywordflow">else</span>
<a name="l00758"></a>00758             {
<a name="l00759"></a>00759                 <span class="keyword">const</span> pixel_src Color = <a class="code" href="namespace_bx_draw_global.html#a3dc452d155a051598cf0038062a2a7d8" title="네이티브소스로 색상전환(X888→NativeSrc)">BxDrawGlobal::ColorX888ToNativeSrc</a>(_DrawOption::CurColor());
<a name="l00760"></a>00760                 <span class="keywordflow">switch</span>(~(rowLength - 1) &amp; 0x3F)
<a name="l00761"></a>00761                 <span class="keywordflow">while</span>(rowBuffer &lt; RowBufferEnd)
<a name="l00762"></a>00762                     CASE64(\
<a name="l00763"></a>00763                     <span class="keywordflow">if</span>(MASKOP == maskoperate_all_print || (MASKOP == maskoperate_print_by_1 &amp;&amp; (*rowBuffer &amp; _MASK_BIT_)) || (MASKOP == maskoperate_print_by_0 &amp;&amp; (~*rowBuffer &amp; _MASK_BIT_)))\
<a name="l00764"></a>00764                     {\
<a name="l00765"></a>00765                         *rowBuffer = <a class="code" href="namespace_bx_draw_global.html#a3af8af57551ff51e3584484517014b4c" title="스프라이트 블렌딩">BxDrawGlobal::SpriteBlending</a>(*rowBuffer, Color, blendSpriteTable);\
<a name="l00766"></a>00766                         if(<a class="code" href="namespace_bx_draw_global.html#a4cb0b256ca23670eb23ac466be2fcb42" title="스타일-마스크">MASK</a> == maskflag_write_1) *rowBuffer |= _MASK_BIT_;\
<a name="l00767"></a>00767                         if(<a class="code" href="namespace_bx_draw_global.html#a4cb0b256ca23670eb23ac466be2fcb42" title="스타일-마스크">MASK</a> == maskflag_write_0) *rowBuffer &amp;= ~_MASK_BIT_;\
<a name="l00768"></a>00768                     }\
<a name="l00769"></a>00769                     ++rowBuffer;)
<a name="l00770"></a>00770             }
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773         #ifdef __BX_OPENGL
<a name="l00774"></a>00774         <span class="keyword">virtual</span> <span class="keywordtype">void</span> _UpdateFormGL()
<a name="l00775"></a>00775         {
<a name="l00776"></a>00776             <span class="keywordflow">if</span>(FormGL)
<a name="l00777"></a>00777             {
<a name="l00778"></a>00778                 <span class="keywordflow">if</span>(BxCore::OpenGL2D::Form_ColorAmbient_GetColor(FormGL) != _DrawOption::CurColor())
<a name="l00779"></a>00779                 {
<a name="l00780"></a>00780                     BxCore::OpenGL2D::FreeForm(FormGL);
<a name="l00781"></a>00781                     FormGL = BxCore::OpenGL2D::MakeForm_ColorAmbient(_DrawOption::CurColor());
<a name="l00782"></a>00782                 }
<a name="l00783"></a>00783             }
<a name="l00784"></a>00784             <span class="keywordflow">else</span>
<a name="l00785"></a>00785             {
<a name="l00786"></a>00786                 FormGL = BxCore::OpenGL2D::MakeForm_ColorAmbient(_DrawOption::CurColor());
<a name="l00787"></a>00787             }
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789 <span class="preprocessor">        #endif</span>
<a name="l00790"></a>00790 <span class="preprocessor"></span>    };
<a name="l00792"></a>00792 
<a name="l00794"></a>00794     <span class="comment">// 스택관리</span>
<a name="l00795"></a>00795     <span class="keyword">class </span>_DrawStack
<a name="l00796"></a>00796     {
<a name="l00797"></a>00797     <span class="keyword">public</span>:
<a name="l00798"></a>00798         <span class="keyword">enum</span> {MAX = 256};
<a name="l00799"></a>00799         stack CountCurrently;
<a name="l00800"></a>00800         stack Count[MAX * drawstyle_max];
<a name="l00801"></a>00801         <span class="keywordtype">int</span> CountFocus;
<a name="l00802"></a>00802         drawstyle Order[MAX * drawstyle_max];
<a name="l00803"></a>00803         <span class="keywordtype">int</span> OrderFocus;
<a name="l00804"></a>00804         <span class="comment">// 스타일</span>
<a name="l00805"></a>00805         <span class="keyword">struct </span>{<a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Rect; <a class="code" href="structpoint.html" title="point구조체 : x, y">point</a> Offset; <a class="code" href="structsize.html" title="size구조체 : w, h">size</a> Size;} Clip[MAX];
<a name="l00806"></a>00806         <span class="keyword">struct </span>{maskoperate Operate; maskflag Flag;} Mask[MAX];
<a name="l00807"></a>00807         <span class="keyword">struct </span>{drawturn Turn; byte Angle;} Rotate[MAX];
<a name="l00808"></a>00808         <span class="keyword">struct </span>{fint Horizon; fint Vertical;} Scale[MAX];
<a name="l00809"></a>00809         <span class="keyword">struct </span>{byte R; byte G; byte B; uint Sum; color_x888 Color;} Color[MAX];
<a name="l00810"></a>00810         byte Hue[MAX];
<a name="l00811"></a>00811         <span class="keyword">struct </span>{byte Opacity255; <span class="keywordtype">int</span> Opacity7;} Opacity[MAX];
<a name="l00812"></a>00812         drawblend Blend[MAX];
<a name="l00813"></a>00813         <span class="keyword">struct </span>{<a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>* Form; <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Rect;} Form[MAX];
<a name="l00814"></a>00814         <a class="code" href="structvertex.html" title="vertex구조체 : x, y, z">vertex</a> Move3D[MAX];
<a name="l00815"></a>00815         <span class="keywordtype">int</span> StyleFocus[drawstyle_max];
<a name="l00816"></a>00816         <span class="comment">// 초기화</span>
<a name="l00817"></a>00817         <span class="keywordtype">void</span> <a class="code" href="namespace_bx_core_1_1_surface.html#a0a25a1a66266f4b181d34903f7d61c02" title="화면생성">Init</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> Width, <span class="keyword">const</span> <span class="keywordtype">int</span> Height)
<a name="l00818"></a>00818         {
<a name="l00819"></a>00819             <span class="comment">// 스택관리</span>
<a name="l00820"></a>00820             CountFocus = -1;
<a name="l00821"></a>00821             OrderFocus = -1;
<a name="l00822"></a>00822             <span class="comment">// 개별스택</span>
<a name="l00823"></a>00823             Clip[0].Rect.l = 0;
<a name="l00824"></a>00824             Clip[0].Rect.t = 0;
<a name="l00825"></a>00825             Clip[0].Rect.r = Width;
<a name="l00826"></a>00826             Clip[0].Rect.b = Height;
<a name="l00827"></a>00827             _DrawOption::CurClipRect() = Clip[0].Rect; <span class="comment">// 현재클리핑</span>
<a name="l00828"></a>00828             Clip[0].Offset.x = _DrawOption::CurHotspotX() = 0; <span class="comment">// 현재기준위치X</span>
<a name="l00829"></a>00829             Clip[0].Offset.y = _DrawOption::CurHotspotY() = 0; <span class="comment">// 현재기준위치Y</span>
<a name="l00830"></a>00830             Clip[0].Size.w = _DrawOption::CurAreaWidth() = Width; <span class="comment">// 현재영역사이즈W</span>
<a name="l00831"></a>00831             Clip[0].Size.h = _DrawOption::CurAreaHeight() = Height; <span class="comment">// 현재영역사이즈H</span>
<a name="l00832"></a>00832             Mask[0].Operate = _DrawOption::CurMaskOperate() = maskoperate_all_print;
<a name="l00833"></a>00833             Mask[0].Flag = _DrawOption::CurMaskFlag() = maskflag_no_write;
<a name="l00834"></a>00834             Rotate[0].Turn = _DrawOption::CurTurn() = turn_0; <span class="comment">// 현재턴</span>
<a name="l00835"></a>00835             Rotate[0].Angle = _DrawOption::CurAngle() = 0; <span class="comment">// 현재각도</span>
<a name="l00836"></a>00836             Scale[0].Horizon = _DrawOption::CurScaleHor() = 0x10000; <span class="comment">// 현재수평배율</span>
<a name="l00837"></a>00837             Scale[0].Vertical = _DrawOption::CurScaleVer() = 0x10000; <span class="comment">// 현재수직배율</span>
<a name="l00838"></a>00838             Color[0].R = 0xFF;
<a name="l00839"></a>00839             Color[0].G = 0xFF;
<a name="l00840"></a>00840             Color[0].B = 0xFF;
<a name="l00841"></a>00841             Color[0].Sum = 0;
<a name="l00842"></a>00842             Color[0].Color = _DrawOption::CurColor() = <a class="code" href="namespace_bx_draw_global.html#a6f404b715a4fced1ab3c989761f96d5f" title="32비트 색상제작">RGB</a>(Color[0].R, Color[0].G, Color[0].B); <span class="comment">// 현재색상</span>
<a name="l00843"></a>00843             Hue[0] = 0;
<a name="l00844"></a>00844             Opacity[0].Opacity255 = 255;
<a name="l00845"></a>00845             Opacity[0].Opacity7 = _DrawOption::CurOpacity7() = 7; <span class="comment">// 현재불투명도</span>
<a name="l00846"></a>00846             Blend[0] = _DrawOption::CurBlend() = blend_normal; <span class="comment">// 현재블랜드</span>
<a name="l00847"></a>00847 <span class="preprocessor">            #ifndef __BX_OPENGL</span>
<a name="l00848"></a>00848 <span class="preprocessor"></span>            _DrawOption::CurSpriteTable() = _DrawOption::GetSpriteTable(blend_normal);
<a name="l00849"></a>00849             _DrawOption::CurAlphaTable() = _DrawOption::GetAlphaTable(blend_normal);
<a name="l00850"></a>00850 <span class="preprocessor">            #endif</span>
<a name="l00851"></a>00851 <span class="preprocessor"></span>            Form[0].Form = _DrawOption::CurForm() = _BxColorMap::GetClass(); <span class="comment">// 현재폼</span>
<a name="l00852"></a>00852             Form[0].Rect = _DrawOption::CurFormRect() = XYWH(0, 0, size::max, size::max); <span class="comment">// 현재폼영역</span>
<a name="l00853"></a>00853             Move3D[0].x = _DrawOption::CurMoveX3D() = 0; <span class="comment">// 현재이동위치X3D</span>
<a name="l00854"></a>00854             Move3D[0].y = _DrawOption::CurMoveY3D() = 0; <span class="comment">// 현재이동위치Y3D</span>
<a name="l00855"></a>00855             Move3D[0].z = _DrawOption::CurMoveZ3D() = 0; <span class="comment">// 현재이동위치Z3D</span>
<a name="l00856"></a>00856             <span class="comment">// 스택포커스</span>
<a name="l00857"></a>00857             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; drawstyle_max; ++i)
<a name="l00858"></a>00858                 StyleFocus[i] = 0;
<a name="l00859"></a>00859         }
<a name="l00860"></a>00860         <span class="comment">// 제거</span>
<a name="l00861"></a>00861         <span class="keywordtype">void</span> Sub()
<a name="l00862"></a>00862         {
<a name="l00863"></a>00863             BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, 0 &lt;= CountFocus);
<a name="l00864"></a>00864             <span class="keywordflow">for</span>(uint i = 0; i &lt; Count[CountFocus]; ++i)
<a name="l00865"></a>00865             {
<a name="l00866"></a>00866                 BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, 0 &lt;= OrderFocus);
<a name="l00867"></a>00867                 BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, 0 &lt; StyleFocus[Order[OrderFocus]]);
<a name="l00868"></a>00868                 <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = --StyleFocus[Order[OrderFocus]];
<a name="l00869"></a>00869                 <span class="keywordflow">switch</span>(Order[OrderFocus--])
<a name="l00870"></a>00870                 {
<a name="l00871"></a>00871                 <span class="keywordflow">case</span> drawstyle_clip: _DrawOption::CurClipRect() = Clip[Focus].Rect; <span class="comment">// 현재클리핑</span>
<a name="l00872"></a>00872                     _DrawOption::CurHotspotX() = Clip[Focus].Offset.x; _DrawOption::CurHotspotY() = Clip[Focus].Offset.y; <span class="comment">// 현재기준위치</span>
<a name="l00873"></a>00873                     _DrawOption::CurAreaWidth() = Clip[Focus].Size.w; _DrawOption::CurAreaHeight() = Clip[Focus].Size.h; <span class="comment">// 현재영역사이즈</span>
<a name="l00874"></a>00874 <span class="preprocessor">                    #ifdef __BX_OPENGL</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span>                    BxCore::OpenGL2D::Clip(_DrawOption::CurClipRect());
<a name="l00876"></a>00876 <span class="preprocessor">                    #endif</span>
<a name="l00877"></a>00877 <span class="preprocessor"></span>                    <span class="keywordflow">break</span>;
<a name="l00878"></a>00878                 <span class="keywordflow">case</span> drawstyle_mask:
<a name="l00879"></a>00879                     _DrawOption::CurMaskOperate() = Mask[Focus].Operate; <span class="comment">// 현재마스킹조작계</span>
<a name="l00880"></a>00880                     _DrawOption::CurMaskFlag() = Mask[Focus].Flag; <span class="comment">// 현재마스킹플래그</span>
<a name="l00881"></a>00881                     <span class="keywordflow">break</span>;
<a name="l00882"></a>00882                 <span class="keywordflow">case</span> drawstyle_rotate: _DrawOption::CurTurn() = Rotate[Focus].Turn; _DrawOption::CurAngle() = Rotate[Focus].Angle; <span class="keywordflow">break</span>; <span class="comment">// 현재턴, 현재각도</span>
<a name="l00883"></a>00883                 <span class="keywordflow">case</span> drawstyle_scale: _DrawOption::CurScaleHor() = Scale[Focus].Horizon; _DrawOption::CurScaleVer() = Scale[Focus].Vertical; <span class="keywordflow">break</span>; <span class="comment">// 현재배율</span>
<a name="l00884"></a>00884                 <span class="keywordflow">case</span> drawstyle_color: _DrawOption::CurColor() = Color[Focus].Color; <span class="keywordflow">break</span>; <span class="comment">// 현재색상</span>
<a name="l00885"></a>00885                 <span class="keywordflow">case</span> drawstyle_hue: <span class="keywordflow">break</span>;
<a name="l00886"></a>00886                 <span class="keywordflow">case</span> drawstyle_opacity: _DrawOption::CurOpacity7() = Opacity[Focus].Opacity7; <span class="keywordflow">break</span>; <span class="comment">// 현재불투명도</span>
<a name="l00887"></a>00887                 <span class="keywordflow">case</span> drawstyle_blend: _DrawOption::CurBlend() = Blend[Focus]; <span class="comment">// 현재블랜드</span>
<a name="l00888"></a>00888 <span class="preprocessor">                    #ifndef __BX_OPENGL</span>
<a name="l00889"></a>00889 <span class="preprocessor"></span>                    _DrawOption::CurSpriteTable() = _DrawOption::GetSpriteTable(Blend[Focus]);
<a name="l00890"></a>00890                     _DrawOption::CurAlphaTable() = _DrawOption::GetAlphaTable(Blend[Focus]);
<a name="l00891"></a>00891 <span class="preprocessor">                    #endif</span>
<a name="l00892"></a>00892 <span class="preprocessor"></span>                    <span class="keywordflow">break</span>;
<a name="l00893"></a>00893                 <span class="keywordflow">case</span> drawstyle_form:
<a name="l00894"></a>00894                     _DrawOption::CurForm() = Form[Focus].Form; <span class="comment">// 현재폼</span>
<a name="l00895"></a>00895                     _DrawOption::CurFormRect() = Form[Focus].Rect; <span class="comment">// 현재폼영역</span>
<a name="l00896"></a>00896                     <span class="keywordflow">break</span>;
<a name="l00897"></a>00897                 <span class="keywordflow">case</span> drawstyle_event: <span class="keywordflow">break</span>;
<a name="l00898"></a>00898                 <span class="keywordflow">case</span> drawstyle_move3d: <span class="comment">// 현재이동위치3D</span>
<a name="l00899"></a>00899                     _DrawOption::CurMoveX3D() = Move3D[Focus].x;
<a name="l00900"></a>00900                     _DrawOption::CurMoveY3D() = Move3D[Focus].y;
<a name="l00901"></a>00901                     _DrawOption::CurMoveZ3D() = Move3D[Focus].z;
<a name="l00902"></a>00902                     <span class="keywordflow">break</span>;
<a name="l00903"></a>00903                 }
<a name="l00904"></a>00904             }
<a name="l00905"></a>00905             --CountFocus;
<a name="l00906"></a>00906         }
<a name="l00907"></a>00907     };
<a name="l00909"></a>00909 
<a name="l00911"></a>00911     <span class="keyword">inline</span> _DrawStack&amp; Stack() {global_data _DrawStack _Stack; <span class="keywordflow">return</span> _Stack;}
<a name="l00913"></a>00913 
<a name="l00921"></a><a class="code" href="namespace_bx_draw_global.html#ac41031f42d66b28fe243c2a14d31106f">00921</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#ac41031f42d66b28fe243c2a14d31106f" title="스타일-클리핑">CLIP</a>(<a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> r, <span class="keywordtype">int</span> hx = 0, <span class="keywordtype">int</span> hy = 0)
<a name="l00922"></a>00922     {
<a name="l00923"></a>00923         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_clip];
<a name="l00924"></a>00924         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l00925"></a>00925         Stack().Clip[Focus].Rect.l = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(Stack().Clip[Focus - 1].Rect.l, Stack().Clip[Focus - 1].Offset.x + r.l);
<a name="l00926"></a>00926         Stack().Clip[Focus].Rect.t = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(Stack().Clip[Focus - 1].Rect.t, Stack().Clip[Focus - 1].Offset.y + r.t);
<a name="l00927"></a>00927         Stack().Clip[Focus].Rect.r = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(Stack().Clip[Focus - 1].Rect.r, Stack().Clip[Focus - 1].Offset.x + r.r);
<a name="l00928"></a>00928         Stack().Clip[Focus].Rect.b = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(Stack().Clip[Focus - 1].Rect.b, Stack().Clip[Focus - 1].Offset.y + r.b);
<a name="l00929"></a>00929         _DrawOption::CurClipRect() = Stack().Clip[Focus].Rect;
<a name="l00930"></a>00930         Stack().Clip[Focus].Offset.x = _DrawOption::CurHotspotX() = Stack().Clip[Focus - 1].Offset.x + ((r.l != -size::max / 2)? r.l : 0) + hx; <span class="comment">// 현재기준위치X</span>
<a name="l00931"></a>00931         Stack().Clip[Focus].Offset.y = _DrawOption::CurHotspotY() = Stack().Clip[Focus - 1].Offset.y + ((r.t != -size::max / 2)? r.t : 0) + hy; <span class="comment">// 현재기준위치Y</span>
<a name="l00932"></a>00932         Stack().Clip[Focus].Size.w = _DrawOption::CurAreaWidth() = r.r - r.l; <span class="comment">// 현재영역사이즈W</span>
<a name="l00933"></a>00933         Stack().Clip[Focus].Size.h = _DrawOption::CurAreaHeight() = r.b - r.t; <span class="comment">// 현재영역사이즈H</span>
<a name="l00934"></a>00934         <span class="comment">// 스택증가</span>
<a name="l00935"></a>00935         Stack().Order[++Stack().OrderFocus] = drawstyle_clip;
<a name="l00936"></a>00936         ++Stack().CountCurrently;
<a name="l00937"></a>00937 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l00938"></a>00938 <span class="preprocessor"></span>        BxCore::OpenGL2D::Clip(_DrawOption::CurClipRect());
<a name="l00939"></a>00939 <span class="preprocessor">        #endif</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span>        <span class="keywordflow">return</span> 1;
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942 
<a name="l00949"></a><a class="code" href="namespace_bx_draw_global.html#a4e1515c7845d3f13cc0c6cc47940c209">00949</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a4e1515c7845d3f13cc0c6cc47940c209" title="스타일-중점이동">HOTSPOT</a>(<span class="keywordtype">int</span> hx, <span class="keywordtype">int</span> hy)
<a name="l00950"></a>00950     {
<a name="l00951"></a>00951         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#ac41031f42d66b28fe243c2a14d31106f" title="스타일-클리핑">CLIP</a>(<a class="code" href="namespace_bx_draw_global.html#ae284872147dbce083bbdddfbcf6cf057" title="위치제작">BxDrawGlobal::XYXY</a>(-size::max / 2, -size::max / 2, size::max / 2, size::max / 2), hx, hy);
<a name="l00952"></a>00952     }
<a name="l00953"></a>00953 
<a name="l00960"></a><a class="code" href="namespace_bx_draw_global.html#a4cb0b256ca23670eb23ac466be2fcb42">00960</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a4cb0b256ca23670eb23ac466be2fcb42" title="스타일-마스크">MASK</a>(maskoperate operate = maskoperate_default, maskflag flag = maskflag_default)
<a name="l00961"></a>00961     {
<a name="l00962"></a>00962         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_mask];
<a name="l00963"></a>00963         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l00964"></a>00964         Stack().Mask[Focus].Operate = _DrawOption::CurMaskOperate() = (operate != maskoperate_default)? operate : Stack().Mask[Focus - 1].Operate;
<a name="l00965"></a>00965         Stack().Mask[Focus].Flag = _DrawOption::CurMaskFlag() = (flag != maskflag_default)? flag : Stack().Mask[Focus - 1].Flag;
<a name="l00966"></a>00966         <span class="comment">// 스택증가</span>
<a name="l00967"></a>00967         Stack().Order[++Stack().OrderFocus] = drawstyle_mask;
<a name="l00968"></a>00968         ++Stack().CountCurrently;
<a name="l00969"></a>00969         <span class="keywordflow">return</span> 1;
<a name="l00970"></a>00970     }
<a name="l00971"></a>00971 
<a name="l00978"></a><a class="code" href="namespace_bx_draw_global.html#ad1bbc9564447e6ccd1affff89fb3724f">00978</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#ad1bbc9564447e6ccd1affff89fb3724f" title="스타일-회전">ROTATE</a>(<span class="keywordtype">int</span> angle1024, <span class="keywordtype">bool</span> doFlip = <span class="keyword">false</span>)
<a name="l00979"></a>00979     {
<a name="l00980"></a>00980         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_rotate];
<a name="l00981"></a>00981         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l00982"></a>00982         angle1024 += (Stack().Rotate[Focus - 1].Turn / 2) * 256 + Stack().Rotate[Focus - 1].Angle;
<a name="l00983"></a>00983         angle1024 = (angle1024 + (1024 &lt;&lt; 16)) % 1024;
<a name="l00984"></a>00984         Stack().Rotate[Focus].Turn = _DrawOption::CurTurn() = (drawturn)(angle1024 / 256 * 2 + ((Stack().Rotate[Focus - 1].Turn + doFlip) % 2)); <span class="comment">// 현재턴</span>
<a name="l00985"></a>00985         Stack().Rotate[Focus].Angle = _DrawOption::CurAngle() = angle1024 &amp; 0xFF;
<a name="l00986"></a>00986         <span class="comment">// 스택증가</span>
<a name="l00987"></a>00987         Stack().Order[++Stack().OrderFocus] = drawstyle_rotate;
<a name="l00988"></a>00988         ++Stack().CountCurrently;
<a name="l00989"></a>00989         <span class="keywordflow">return</span> 1;
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991 
<a name="l00998"></a><a class="code" href="namespace_bx_draw_global.html#a4d55b81dfe06436f9b590d64c3ed2df5">00998</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a4d55b81dfe06436f9b590d64c3ed2df5" title="스타일-확대율(fint)">SCALE</a>(fint hor, fint ver)
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_scale];
<a name="l01001"></a>01001         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01002"></a>01002         Stack().Scale[Focus].Horizon = _DrawOption::CurScaleHor() = (fint)((((huge) Stack().Scale[Focus - 1].Horizon) * hor) &gt;&gt; 16); <span class="comment">// 현재수평배율</span>
<a name="l01003"></a>01003         Stack().Scale[Focus].Vertical = _DrawOption::CurScaleVer() = (fint)((((huge) Stack().Scale[Focus - 1].Vertical) * ver) &gt;&gt; 16); <span class="comment">// 현재수직배율</span>
<a name="l01004"></a>01004         <span class="comment">// 스택증가</span>
<a name="l01005"></a>01005         Stack().Order[++Stack().OrderFocus] = drawstyle_scale;
<a name="l01006"></a>01006         ++Stack().CountCurrently;
<a name="l01007"></a>01007         <span class="keywordflow">return</span> 1;
<a name="l01008"></a>01008     }
<a name="l01009"></a>01009 
<a name="l01016"></a><a class="code" href="namespace_bx_draw_global.html#a3fd91458562587f09b8be59753690e01">01016</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a4d55b81dfe06436f9b590d64c3ed2df5" title="스타일-확대율(fint)">SCALE</a>(<span class="keywordtype">double</span> hor, <span class="keywordtype">double</span> ver)
<a name="l01017"></a>01017     {
<a name="l01018"></a>01018         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#a4d55b81dfe06436f9b590d64c3ed2df5" title="스타일-확대율(fint)">SCALE</a>((<span class="keywordtype">int</span>)(0x10000 * hor + 0.5), (<span class="keywordtype">int</span>)(0x10000 * ver + 0.5));
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020 
<a name="l01029"></a><a class="code" href="namespace_bx_draw_global.html#a995e3167e7c9bf9892c0ffb3261120c2">01029</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a995e3167e7c9bf9892c0ffb3261120c2" title="스타일-컬러링(byte)">COLOR</a>(byte r, byte g, byte b, uint rate = 100)
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_color];
<a name="l01032"></a>01032         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01033"></a>01033         Stack().Color[Focus].R = (Stack().Color[Focus - 1].R * Stack().Color[Focus - 1].Sum + r * rate) / (Stack().Color[Focus - 1].Sum + rate);
<a name="l01034"></a>01034         Stack().Color[Focus].G = (Stack().Color[Focus - 1].G * Stack().Color[Focus - 1].Sum + g * rate) / (Stack().Color[Focus - 1].Sum + rate);
<a name="l01035"></a>01035         Stack().Color[Focus].B = (Stack().Color[Focus - 1].B * Stack().Color[Focus - 1].Sum + b * rate) / (Stack().Color[Focus - 1].Sum + rate);
<a name="l01036"></a>01036         Stack().Color[Focus].Sum = Stack().Color[Focus - 1].Sum + rate;
<a name="l01037"></a>01037         Stack().Color[Focus].Color = _DrawOption::CurColor() = <a class="code" href="namespace_bx_draw_global.html#a6f404b715a4fced1ab3c989761f96d5f" title="32비트 색상제작">RGB</a>(Stack().Color[Focus].R, Stack().Color[Focus].G, Stack().Color[Focus].B); <span class="comment">// 현재색상</span>
<a name="l01038"></a>01038         <span class="comment">// 스택증가</span>
<a name="l01039"></a>01039         Stack().Order[++Stack().OrderFocus] = drawstyle_color;
<a name="l01040"></a>01040         ++Stack().CountCurrently;
<a name="l01041"></a>01041         <span class="keywordflow">return</span> 1;
<a name="l01042"></a>01042     }
<a name="l01043"></a>01043 
<a name="l01050"></a><a class="code" href="namespace_bx_draw_global.html#aedaf398a979acea1bafba856d31b78b6">01050</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a995e3167e7c9bf9892c0ffb3261120c2" title="스타일-컬러링(byte)">COLOR</a>(color_x888 rgb, uint rate = 100)
<a name="l01051"></a>01051     {
<a name="l01052"></a>01052         <span class="keywordflow">return</span> <a class="code" href="namespace_bx_draw_global.html#a995e3167e7c9bf9892c0ffb3261120c2" title="스타일-컬러링(byte)">COLOR</a>((rgb &gt;&gt; 16) &amp; 0xFF, (rgb &gt;&gt; 8) &amp; 0xFF, rgb &amp; 0xFF, rate);
<a name="l01053"></a>01053     }
<a name="l01054"></a>01054 
<a name="l01056"></a>01056     <span class="keyword">static</span> stack HUE(byte hue)
<a name="l01057"></a>01057     {
<a name="l01058"></a>01058         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_hue];
<a name="l01059"></a>01059         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01060"></a>01060         Stack().Hue[Focus] = Stack().Hue[Focus - 1] + hue;
<a name="l01061"></a>01061         <span class="comment">// 스택증가</span>
<a name="l01062"></a>01062         Stack().Order[++Stack().OrderFocus] = drawstyle_hue;
<a name="l01063"></a>01063         ++Stack().CountCurrently;
<a name="l01064"></a>01064         <span class="keywordflow">return</span> 1;
<a name="l01065"></a>01065     }
<a name="l01067"></a>01067 
<a name="l01073"></a><a class="code" href="namespace_bx_draw_global.html#a1b0e942d04e48b394fc70d30c3897cb9">01073</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a1b0e942d04e48b394fc70d30c3897cb9" title="스타일-불투명도">OPACITY</a>(byte opa)
<a name="l01074"></a>01074     {
<a name="l01075"></a>01075         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_opacity];
<a name="l01076"></a>01076         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01077"></a>01077         Stack().Opacity[Focus].Opacity255 = Stack().Opacity[Focus - 1].Opacity255 * opa / 255;
<a name="l01078"></a>01078         Stack().Opacity[Focus].Opacity7 = _DrawOption::CurOpacity7() = 8 * Stack().Opacity[Focus].Opacity255 / 255 - 1; <span class="comment">// 현재불투명도</span>
<a name="l01079"></a>01079         <span class="comment">// 스택증가</span>
<a name="l01080"></a>01080         Stack().Order[++Stack().OrderFocus] = drawstyle_opacity;
<a name="l01081"></a>01081         ++Stack().CountCurrently;
<a name="l01082"></a>01082         <span class="keywordflow">return</span> 1;
<a name="l01083"></a>01083     }
<a name="l01084"></a>01084 
<a name="l01090"></a><a class="code" href="namespace_bx_draw_global.html#a1a3987e641d7c7068a767ca9920845b9">01090</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a1a3987e641d7c7068a767ca9920845b9" title="스타일-블렌딩">BLEND</a>(drawblend blend)
<a name="l01091"></a>01091     {
<a name="l01092"></a>01092         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_blend];
<a name="l01093"></a>01093         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01094"></a>01094         Stack().Blend[Focus] = _DrawOption::CurBlend() = blend; <span class="comment">// 현재블랜드</span>
<a name="l01095"></a>01095 <span class="preprocessor">        #ifndef __BX_OPENGL</span>
<a name="l01096"></a>01096 <span class="preprocessor"></span>        _DrawOption::CurSpriteTable() = _DrawOption::GetSpriteTable(blend);
<a name="l01097"></a>01097         _DrawOption::CurAlphaTable() = _DrawOption::GetAlphaTable(blend);
<a name="l01098"></a>01098 <span class="preprocessor">        #endif</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span>        <span class="comment">// 스택증가</span>
<a name="l01100"></a>01100         Stack().Order[++Stack().OrderFocus] = drawstyle_blend;
<a name="l01101"></a>01101         ++Stack().CountCurrently;
<a name="l01102"></a>01102         <span class="keywordflow">return</span> 1;
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104 
<a name="l01111"></a><a class="code" href="namespace_bx_draw_global.html#a34fac7d49bf9583a466d8f995993aefc">01111</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#a34fac7d49bf9583a466d8f995993aefc" title="스타일-채우기">FORM</a>(<a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>* form = null, <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> r = XYWH(0, 0, size::max, size::max))
<a name="l01112"></a>01112     {
<a name="l01113"></a>01113         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_form];
<a name="l01114"></a>01114         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01115"></a>01115         Stack().Form[Focus].Form = _DrawOption::CurForm() = (form)? form : _BxColorMap::GetClass(); <span class="comment">// 현재폼</span>
<a name="l01116"></a>01116         Stack().Form[Focus].Rect = _DrawOption::CurFormRect() = r; <span class="comment">// 현재폼영역</span>
<a name="l01117"></a>01117         <span class="comment">// 스택증가</span>
<a name="l01118"></a>01118         Stack().Order[++Stack().OrderFocus] = drawstyle_form;
<a name="l01119"></a>01119         ++Stack().CountCurrently;
<a name="l01120"></a>01120         <span class="keywordflow">return</span> 1;
<a name="l01121"></a>01121     }
<a name="l01122"></a>01122 
<a name="l01130"></a><a class="code" href="namespace_bx_draw_global.html#af4d76a41a433f0e3927a602b551e2a39">01130</a>     <span class="keyword">static</span> stack <a class="code" href="namespace_bx_draw_global.html#af4d76a41a433f0e3927a602b551e2a39" title="스타일-3D모델이동">MOVE3D</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z)
<a name="l01131"></a>01131     {
<a name="l01132"></a>01132         <span class="keyword">const</span> <span class="keywordtype">int</span> Focus = ++Stack().StyleFocus[drawstyle_move3d];
<a name="l01133"></a>01133         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, Focus &lt; Stack().MAX);
<a name="l01134"></a>01134         Stack().Move3D[Focus].x = _DrawOption::CurMoveX3D() = Stack().Move3D[Focus - 1].x + x; <span class="comment">// 현재이동위치3D</span>
<a name="l01135"></a>01135         Stack().Move3D[Focus].y = _DrawOption::CurMoveY3D() = Stack().Move3D[Focus - 1].y + y;
<a name="l01136"></a>01136         Stack().Move3D[Focus].z = _DrawOption::CurMoveZ3D() = Stack().Move3D[Focus - 1].z + z;
<a name="l01137"></a>01137         <span class="comment">// 스택증가</span>
<a name="l01138"></a>01138         Stack().Order[++Stack().OrderFocus] = drawstyle_move3d;
<a name="l01139"></a>01139         ++Stack().CountCurrently;
<a name="l01140"></a>01140         <span class="keywordflow">return</span> 1;
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142 }
<a name="l01143"></a>01143 
<a name="l01145"></a><a class="code" href="class_bx_draw.html">01145</a> <span class="keyword">class </span><a class="code" href="class_bx_draw.html" title="OpenGL/SW랜더링기반 그리기도구">BxDraw</a>
<a name="l01146"></a>01146 {
<a name="l01147"></a>01147     global_func <span class="keyword">inline</span> <span class="keywordtype">bool</span>&amp; IsActivated() {global_data <span class="keywordtype">bool</span> isActivated = <span class="keyword">false</span>; <span class="keywordflow">return</span> isActivated;}
<a name="l01148"></a>01148 
<a name="l01149"></a>01149 <span class="keyword">public</span>:
<a name="l01153"></a><a class="code" href="class_bx_draw.html#a8428f4d8b7e8afcd637a75ca20a0d37c">01153</a>     <a class="code" href="class_bx_draw.html" title="OpenGL/SW랜더링기반 그리기도구">BxDraw</a>() : FigureMapWidthFix(32), FigureMapWidthLevel(5)
<a name="l01154"></a>01154     {
<a name="l01155"></a>01155         BxAssert(<span class="stringliteral">&quot;BxDraw&lt;생성수량이 허용치인 1을 초과합니다&gt;&quot;</span>, !IsActivated());
<a name="l01156"></a>01156         IsActivated() = <span class="keyword">true</span>;
<a name="l01157"></a>01157 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01158"></a>01158 <span class="preprocessor"></span>        BxCore::OpenGL2D::Init();
<a name="l01159"></a>01159 <span class="preprocessor">        #endif</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>        <span class="comment">// 방향성(에뮬은 비활성)</span>
<a name="l01161"></a>01161         dirtype dir = dir_rot0;
<a name="l01162"></a>01162 <span class="preprocessor">        #if defined(__GNUC__) || defined(__ARMCC_VERSION)</span>
<a name="l01163"></a>01163 <span class="preprocessor"></span>        <span class="keywordtype">int</span> DispFixRot;
<a name="l01164"></a>01164         <a class="code" href="namespace_bx_core_1_1_system.html#ab6cffede1b1ee9298c72042babb94125" title="정수형 icf값 불러오기">BxCore::System::GetConfigInt</a>(<span class="stringliteral">&quot;s3e&quot;</span>, <span class="stringliteral">&quot;DispFixRot&quot;</span>, &amp;DispFixRot);
<a name="l01165"></a>01165         <span class="keywordflow">switch</span>(DispFixRot)
<a name="l01166"></a>01166         {
<a name="l01167"></a>01167         <span class="keywordflow">case</span> 1: dir = dir_rot0; <span class="keywordflow">break</span>;
<a name="l01168"></a>01168         <span class="keywordflow">case</span> 2: dir = dir_rot90; <span class="keywordflow">break</span>;
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170 <span class="preprocessor">        #endif</span>
<a name="l01171"></a>01171 <span class="preprocessor"></span>        <a class="code" href="namespace_bx_core_1_1_surface.html#a0a25a1a66266f4b181d34903f7d61c02" title="화면생성">BxCore::Surface::Init</a>(dir);
<a name="l01172"></a>01172         <span class="comment">// 버튼이벤트초기화</span>
<a name="l01173"></a>01173         ButtonLength = 0;
<a name="l01174"></a>01174         IsButtonEventFinished = <span class="keyword">false</span>;
<a name="l01175"></a>01175         <span class="comment">// 도형버퍼초기화</span>
<a name="l01176"></a>01176         FigureMapHeight = 0;
<a name="l01177"></a>01177         FigureMap = null;
<a name="l01178"></a>01178         <span class="comment">// 백버퍼 초기화</span>
<a name="l01179"></a>01179         BackBufferWidth = 0;
<a name="l01180"></a>01180         BackBufferHeight = 0;
<a name="l01181"></a>01181         BackBufferPtr = null;
<a name="l01182"></a>01182         Flush(<span class="keyword">true</span>);
<a name="l01183"></a>01183     }
<a name="l01184"></a>01184 
<a name="l01188"></a><a class="code" href="class_bx_draw.html#a76b4a684ffb3790d3f48795a5f6fb556">01188</a>     ~<a class="code" href="class_bx_draw.html" title="OpenGL/SW랜더링기반 그리기도구">BxDraw</a>()
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190         <span class="comment">// 백버퍼 제거</span>
<a name="l01191"></a>01191         BxDelete_Array(BackBufferPtr);
<a name="l01192"></a>01192         <span class="comment">// 도형버퍼 제거</span>
<a name="l01193"></a>01193         FigureMapHeight = 0;
<a name="l01194"></a>01194         BxDelete_Array(FigureMap);
<a name="l01195"></a>01195         IsActivated() = <span class="keyword">false</span>;
<a name="l01196"></a>01196     }
<a name="l01197"></a>01197 
<a name="l01202"></a><a class="code" href="class_bx_draw.html#ad633ce6baf25d6c93dde6669d4093a3e">01202</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> TranslateX()
<a name="l01203"></a>01203     {
<a name="l01204"></a>01204         <span class="keywordflow">return</span> BxDrawGlobal::_DrawOption::CurHotspotX();
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 
<a name="l01211"></a><a class="code" href="class_bx_draw.html#a21597dea9cb25b209963d30307b31baf">01211</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> TranslateY()
<a name="l01212"></a>01212     {
<a name="l01213"></a>01213         <span class="keywordflow">return</span> BxDrawGlobal::_DrawOption::CurHotspotY();
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215 
<a name="l01221"></a><a class="code" href="class_bx_draw.html#a629c65ebda9be9d1dd7c507a30557eb8">01221</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> Width(<span class="keywordtype">bool</span> isScreen = <span class="keyword">false</span>)
<a name="l01222"></a>01222     {
<a name="l01223"></a>01223         <span class="keywordflow">if</span>(isScreen) <span class="keywordflow">return</span> BackBufferWidth;
<a name="l01224"></a>01224         <span class="keywordflow">return</span> BxDrawGlobal::_DrawOption::CurAreaWidth();
<a name="l01225"></a>01225     }
<a name="l01226"></a>01226 
<a name="l01232"></a><a class="code" href="class_bx_draw.html#a378f6d7988a5a667fd3e720c25e6a297">01232</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> Height(<span class="keywordtype">bool</span> isScreen = <span class="keyword">false</span>)
<a name="l01233"></a>01233     {
<a name="l01234"></a>01234         <span class="keywordflow">if</span>(isScreen) <span class="keywordflow">return</span> BackBufferHeight;
<a name="l01235"></a>01235         <span class="keywordflow">return</span> BxDrawGlobal::_DrawOption::CurAreaHeight();
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237 
<a name="l01242"></a><a class="code" href="class_bx_draw.html#ad082728129e5106507963d63f4a622e8">01242</a>     <span class="keyword">inline</span> pixel_dst* <a class="code" href="class_bx_draw.html#ad082728129e5106507963d63f4a622e8" title="백버퍼 주소얻기">GetBackBufferPtr</a>() {<span class="keywordflow">return</span> BackBufferPtr;}
<a name="l01243"></a>01243 
<a name="l01248"></a><a class="code" href="class_bx_draw.html#a0caa56d5fcda446e944fa1ffd397bd10">01248</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="class_bx_draw.html#a0caa56d5fcda446e944fa1ffd397bd10" title="백버퍼 피치정보얻기">GetBackBufferPitch</a>() {<span class="keywordflow">return</span> BackBufferWidth;}
<a name="l01249"></a>01249 
<a name="l01256"></a><a class="code" href="class_bx_draw.html#a249991b848bbc125d853007c466312d1">01256</a>     <span class="keywordtype">void</span> Area(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, stack count = 0)
<a name="l01257"></a>01257     {
<a name="l01258"></a>01258         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01259"></a>01259         <span class="comment">// 무조건 이관</span>
<a name="l01260"></a>01260         <a class="code" href="structarea.html" title="area구조체 : w, h, hx, hy">area</a> FormArea = *BxDrawGlobal::_DrawOption::CurForm()-&gt;GetArea();
<a name="l01261"></a>01261         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01262"></a>01262         FormArea.w = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(FormArea.w, FormRect.r - FormRect.l);
<a name="l01263"></a>01263         FormArea.h = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(FormArea.h, FormRect.b - FormRect.t);
<a name="l01264"></a>01264         x = (x * BxDrawGlobal::_DrawOption::CurScaleHor()) &gt;&gt; 16;
<a name="l01265"></a>01265         y = (y * BxDrawGlobal::_DrawOption::CurScaleVer()) &gt;&gt; 16;
<a name="l01266"></a>01266         <span class="keyword">const</span> uint Angle = BxDrawGlobal::_DrawOption::CurAngle();
<a name="l01267"></a>01267         <span class="keyword">const</span> drawturn Turn = BxDrawGlobal::_DrawOption::CurTurn();
<a name="l01268"></a>01268         <span class="keywordflow">if</span>(0 &lt; Angle || Turn != turn_0)
<a name="l01269"></a>01269         {
<a name="l01270"></a>01270             <span class="keyword">const</span> <span class="keywordtype">int</span> AngleValue = ((1024 &lt;&lt; 16) + (Angle + Turn / 2 * 256)) % 1024;
<a name="l01271"></a>01271             <span class="keyword">const</span> huge AngleCos = <a class="code" href="class_bx_util.html#a1d0271ff4863c0b8fbe8b7f9c1076653" title="Cos값 구하기">BxUtil::Cos</a>(AngleValue);
<a name="l01272"></a>01272             <span class="keyword">const</span> huge AngleSin = <a class="code" href="class_bx_util.html#a19bef9b1c3c37b263ad5d68a9fb710d0" title="Sin값 구하기">BxUtil::Sin</a>(AngleValue);
<a name="l01273"></a>01273             <span class="keyword">const</span> <span class="keywordtype">int</span> AngleFlip = (Turn % 2)? -1 : 1;
<a name="l01274"></a>01274             <span class="keyword">const</span> <span class="keywordtype">int</span> TempX = (int)((AngleFlip * x * AngleCos - y * AngleSin) &gt;&gt; 16);
<a name="l01275"></a>01275             <span class="keyword">const</span> <span class="keywordtype">int</span> TempY = (int)((AngleFlip * x * AngleSin + y * AngleCos) &gt;&gt; 16);
<a name="l01276"></a>01276             x = TempX, y = TempY;
<a name="l01277"></a>01277         }
<a name="l01278"></a>01278         Rectangle(BxDrawGlobal::FILL, BxDrawGlobal::XYWH(-FormArea.hx, -FormArea.hy, FormArea.w, FormArea.h),
<a name="l01279"></a>01279             count + <a class="code" href="namespace_bx_draw_global.html#a4e1515c7845d3f13cc0c6cc47940c209" title="스타일-중점이동">BxDrawGlobal::HOTSPOT</a>(x, y));
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281 
<a name="l01288"></a><a class="code" href="class_bx_draw.html#a8e76967347f6897a6a65289138b72b6b">01288</a>     <span class="keywordtype">void</span> Rectangle(BxDrawGlobal::option opt, <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> r, stack count = 0)
<a name="l01289"></a>01289     {
<a name="l01290"></a>01290         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01291"></a>01291 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01292"></a>01292 <span class="preprocessor"></span>        <span class="comment">// 조건 이관</span>
<a name="l01293"></a>01293         <span class="keywordflow">if</span>(0 &lt; BxDrawGlobal::_DrawOption::CurAngle())
<a name="l01294"></a>01294         {
<a name="l01295"></a>01295             PolygonSt(opt, <a class="code" href="namespace_bx_draw_global.html#a64389bd5a1f1f7affa88ff54ff45b210" title="가변인자식 다각영역제작">BxDrawGlobal::XYS</a>(4, r.l, r.t, r.l, r.b, r.r, r.b, r.r, r.t), count);
<a name="l01296"></a>01296             <span class="keywordflow">return</span>;
<a name="l01297"></a>01297         }
<a name="l01298"></a>01298         <span class="comment">// 모듈</span>
<a name="l01299"></a>01299         <span class="keywordflow">if</span>(AddStyleByIf(count))
<a name="l01300"></a>01300         {
<a name="l01301"></a>01301             <span class="keyword">const</span> <span class="keywordtype">int</span> FormWidth = BxDrawGlobal::_DrawOption::CurForm()-&gt;Width();
<a name="l01302"></a>01302             <span class="keyword">const</span> <span class="keywordtype">int</span> FormHeight = BxDrawGlobal::_DrawOption::CurForm()-&gt;Height();
<a name="l01303"></a>01303             <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a>&amp; FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01304"></a>01304             <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> uvclip;
<a name="l01305"></a>01305             uvclip.l = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.l, FormWidth) / FormWidth);
<a name="l01306"></a>01306             uvclip.t = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.t, FormHeight) / FormHeight);
<a name="l01307"></a>01307             uvclip.r = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.r, FormWidth) / FormWidth);
<a name="l01308"></a>01308             uvclip.b = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.b, FormHeight) / FormHeight);
<a name="l01309"></a>01309             id_opengl_outline Outline = BxCore::OpenGL2D::MakeOutline_VertexUV(r, uvclip);
<a name="l01310"></a>01310             <span class="keywordflow">if</span>(Outline)
<a name="l01311"></a>01311             {
<a name="l01312"></a>01312                 <span class="keyword">const</span> <span class="keywordtype">bool</span> DoFlip = (BxDrawGlobal::_DrawOption::CurTurn() % 2 == 1);
<a name="l01313"></a>01313                 <span class="keyword">const</span> <span class="keywordtype">int</span> Angle = ((1024 &lt;&lt; 16) + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256) % 1024;
<a name="l01314"></a>01314                 BxCore::OpenGL2D::Outline_VertexUV_SetScale(Outline, BxDrawGlobal::_DrawOption::CurScaleHor(), BxDrawGlobal::_DrawOption::CurScaleVer());
<a name="l01315"></a>01315                 BxCore::OpenGL2D::Outline_VertexUV_SetRotate(Outline, Angle, DoFlip);
<a name="l01316"></a>01316                 BxCore::OpenGL2D::Render(BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormGL(), Outline,
<a name="l01317"></a>01317                     BxDrawGlobal::_DrawOption::CurHotspotX(), BxDrawGlobal::_DrawOption::CurHotspotY(),
<a name="l01318"></a>01318                     255 * (BxDrawGlobal::_DrawOption::CurOpacity7() + 1) / 8,
<a name="l01319"></a>01319                     BxDrawGlobal::_DrawOption::CurColor());
<a name="l01320"></a>01320                 BxCore::OpenGL2D::FreeOutline(Outline);
<a name="l01321"></a>01321             }
<a name="l01322"></a>01322             SubStyle();
<a name="l01323"></a>01323         }
<a name="l01324"></a>01324 <span class="preprocessor">        #else</span>
<a name="l01325"></a>01325 <span class="preprocessor"></span>        <span class="comment">// 조건 이관</span>
<a name="l01326"></a>01326         <span class="keywordflow">if</span>(0 &lt; BxDrawGlobal::_DrawOption::CurAngle())
<a name="l01327"></a>01327         {
<a name="l01328"></a>01328             PolygonSt(opt, <a class="code" href="namespace_bx_draw_global.html#a64389bd5a1f1f7affa88ff54ff45b210" title="가변인자식 다각영역제작">BxDrawGlobal::XYS</a>(4, r.l, r.t, r.r - 1, r.t, r.r - 1, r.b - 1, r.l, r.b - 1), count);
<a name="l01329"></a>01329             <span class="keywordflow">return</span>;
<a name="l01330"></a>01330         }
<a name="l01331"></a>01331         <span class="comment">// 모듈</span>
<a name="l01332"></a>01332         <span class="keywordflow">if</span>(!AddStyleByIf(count)) <span class="keywordflow">return</span>;
<a name="l01333"></a>01333         <span class="keyword">const</span> drawturn Turn = BxDrawGlobal::_DrawOption::CurTurn();
<a name="l01334"></a>01334         <span class="keyword">const</span> <span class="keywordtype">bool</span> IsFlip90 = (Turn == turn_90 || Turn == turn_x90 || Turn == turn_270 || Turn == turn_x270);
<a name="l01335"></a>01335         <span class="keyword">const</span> fint ScaleHor = (IsFlip90)? BxDrawGlobal::_DrawOption::CurScaleVer() : BxDrawGlobal::_DrawOption::CurScaleHor();
<a name="l01336"></a>01336         <span class="keyword">const</span> fint ScaleVer = (IsFlip90)? BxDrawGlobal::_DrawOption::CurScaleHor() : BxDrawGlobal::_DrawOption::CurScaleVer();
<a name="l01337"></a>01337         <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> C = {r.l, r.t, r.r, r.b};
<a name="l01338"></a>01338         <span class="keywordflow">switch</span>(Turn)
<a name="l01339"></a>01339         {
<a name="l01340"></a>01340         <span class="keywordflow">case</span> turn_0   :
<a name="l01341"></a>01341         <span class="keywordflow">case</span> turn_x0  : r.l = +C.l; r.t = +C.t; r.r = +C.r; r.b = +C.b; <span class="keywordflow">break</span>;
<a name="l01342"></a>01342         <span class="keywordflow">case</span> turn_90  :
<a name="l01343"></a>01343         <span class="keywordflow">case</span> turn_x90 : r.l = -C.b; r.t = +C.l; r.r = -C.t; r.b = +C.r; <span class="keywordflow">break</span>;
<a name="l01344"></a>01344         <span class="keywordflow">case</span> turn_180 :
<a name="l01345"></a>01345         <span class="keywordflow">case</span> turn_x180: r.l = -C.r; r.t = -C.b; r.r = -C.l; r.b = -C.t; <span class="keywordflow">break</span>;
<a name="l01346"></a>01346         <span class="keywordflow">case</span> turn_270 :
<a name="l01347"></a>01347         <span class="keywordflow">case</span> turn_x270: r.l = +C.t; r.t = -C.r; r.r = +C.b; r.b = -C.l; <span class="keywordflow">break</span>;
<a name="l01348"></a>01348         }
<a name="l01349"></a>01349         <span class="keyword">const</span> <span class="keywordtype">int</span> Left = ((r.l * ScaleHor) &gt;&gt; 16) + BxDrawGlobal::_DrawOption::CurHotspotX();
<a name="l01350"></a>01350         <span class="keyword">const</span> <span class="keywordtype">int</span> Top = ((r.t * ScaleVer) &gt;&gt; 16) + BxDrawGlobal::_DrawOption::CurHotspotY();
<a name="l01351"></a>01351         <span class="keyword">const</span> <span class="keywordtype">int</span> Right = ((r.r * ScaleHor) &gt;&gt; 16) + BxDrawGlobal::_DrawOption::CurHotspotX();
<a name="l01352"></a>01352         <span class="keyword">const</span> <span class="keywordtype">int</span> Bottom = ((r.b * ScaleVer) &gt;&gt; 16) + BxDrawGlobal::_DrawOption::CurHotspotY();
<a name="l01353"></a>01353         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Rect = {
<a name="l01354"></a>01354             <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(BxDrawGlobal::_DrawOption::CurClipRect().l, Left),
<a name="l01355"></a>01355             <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(BxDrawGlobal::_DrawOption::CurClipRect().t, Top),
<a name="l01356"></a>01356             <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(BxDrawGlobal::_DrawOption::CurClipRect().r, Right),
<a name="l01357"></a>01357             <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(BxDrawGlobal::_DrawOption::CurClipRect().b, Bottom)};
<a name="l01358"></a>01358         <span class="keywordflow">if</span>(0 &lt; Rect.r - Rect.l &amp;&amp; 0 &lt; Rect.b - Rect.t)
<a name="l01359"></a>01359         {
<a name="l01360"></a>01360             <span class="comment">// 모듈링준비</span>
<a name="l01361"></a>01361             <span class="keyword">const</span> drawturn Turn = BxDrawGlobal::_DrawOption::CurTurn();
<a name="l01362"></a>01362             <span class="keyword">const</span> <a class="code" href="structarea.html" title="area구조체 : w, h, hx, hy">area</a>&amp; FormArea = *BxDrawGlobal::_DrawOption::CurForm()-&gt;GetArea();
<a name="l01363"></a>01363             <span class="keyword">const</span> <span class="keywordtype">bool</span> IsFlip90 = (Turn == turn_90 || Turn == turn_x90 || Turn == turn_270 || Turn == turn_x270);
<a name="l01364"></a>01364             <span class="keyword">const</span> fint DescaleX = (fint)(Ox100000000 / ScaleHor);
<a name="l01365"></a>01365             <span class="keyword">const</span> fint DescaleY = (fint)(Ox100000000 / ScaleVer);
<a name="l01366"></a>01366             <span class="keyword">const</span> fint XBegin = (IsFlip90)? (Rect.t - Top) * DescaleY : (Rect.l - Left) * DescaleX;
<a name="l01367"></a>01367             <span class="keyword">const</span> fint YBegin = (IsFlip90)? (Rect.l - Left) * DescaleX : (Rect.t - Top) * DescaleY;
<a name="l01368"></a>01368             fint XFocus = (Turn == turn_0 || Turn == turn_90 || Turn == turn_x180 || Turn == turn_x270)? XBegin : (FormArea.w &lt;&lt; 16) - 1 - XBegin;
<a name="l01369"></a>01369             fint YFocus = (Turn == turn_0 || Turn == turn_x0 || Turn == turn_270 || Turn == turn_x270)? YBegin : (FormArea.h &lt;&lt; 16) - 1 - YBegin;
<a name="l01370"></a>01370             <span class="keyword">const</span> fint XVec = (IsFlip90)? 0 : ((Turn == turn_0 || Turn == turn_x180)? DescaleX : -DescaleX);
<a name="l01371"></a>01371             <span class="keyword">const</span> fint YVec = (!IsFlip90)? 0 : ((Turn == turn_x270 || Turn == turn_270)? DescaleX : -DescaleX);
<a name="l01372"></a>01372             <span class="keyword">const</span> fint XAdd = (!IsFlip90)? 0 : ((Turn == turn_90 || Turn == turn_x270)? DescaleY : -DescaleY);
<a name="l01373"></a>01373             <span class="keyword">const</span> fint YAdd = (IsFlip90)? 0 : ((Turn == turn_0 || Turn == turn_x0)? DescaleY : -DescaleY);
<a name="l01374"></a>01374             <span class="comment">// 블렌딩준비</span>
<a name="l01375"></a>01375             pixel_dst* ScreenPtr = GetBackBufferPtr();
<a name="l01376"></a>01376             pixel_dst* Dst = &amp;ScreenPtr[Rect.l + Rect.t * GetBackBufferPitch()];
<a name="l01377"></a>01377             <span class="keyword">const</span> uint DstPitch = GetBackBufferPitch();
<a name="l01378"></a>01378             <span class="keyword">const</span> uint DstCopyLen = Rect.r - Rect.l;
<a name="l01379"></a>01379 <span class="preprocessor">            #ifdef __BX_PIXEL16</span>
<a name="l01380"></a>01380 <span class="preprocessor"></span>                <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (5 + 5)];
<a name="l01381"></a>01381                 <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 5 + 4)];
<a name="l01382"></a>01382 <span class="preprocessor">            #else</span>
<a name="l01383"></a>01383 <span class="preprocessor"></span>                <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (8 + 8)];
<a name="l01384"></a>01384                 <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 8 + 8)];
<a name="l01385"></a>01385 <span class="preprocessor">            #endif</span>
<a name="l01386"></a>01386 <span class="preprocessor"></span>            <span class="comment">// 백버퍼카피</span>
<a name="l01387"></a>01387             <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp; FormClass = *BxDrawGlobal::_DrawOption::CurForm();
<a name="l01388"></a>01388             <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01389"></a>01389             BxDrawForm::OnFormMethod FormMethod = BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormMethod
<a name="l01390"></a>01390                 (BxDrawGlobal::_DrawOption::CurMaskOperate(), BxDrawGlobal::_DrawOption::CurMaskFlag());
<a name="l01391"></a>01391             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0, yend = Rect.b - Rect.t; y &lt; yend; ++y)
<a name="l01392"></a>01392             {
<a name="l01393"></a>01393                 FormMethod(FormClass, FormRect, Dst, DstCopyLen, XFocus, YFocus, XVec, YVec, BlendSpriteTable, BlendAlphaTable);
<a name="l01394"></a>01394                 XFocus += XAdd, YFocus += YAdd;
<a name="l01395"></a>01395                 Dst += DstPitch;
<a name="l01396"></a>01396             }
<a name="l01397"></a>01397         }
<a name="l01398"></a>01398         SubStyle();
<a name="l01399"></a>01399 <span class="preprocessor">        #endif</span>
<a name="l01400"></a>01400 <span class="preprocessor"></span>    }
<a name="l01401"></a>01401 
<a name="l01403"></a>01403     <span class="keywordtype">void</span> Line(<a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> r, stack count = 0)
<a name="l01404"></a>01404     {
<a name="l01405"></a>01405         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01406"></a>01406 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01407"></a>01407 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01408"></a>01408         <span class="keywordflow">if</span>(AddStyleByIf(count))
<a name="l01409"></a>01409         {
<a name="l01411"></a>01411             SubStyle();
<a name="l01412"></a>01412         }
<a name="l01413"></a>01413 <span class="preprocessor">        #else</span>
<a name="l01414"></a>01414 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01415"></a>01415         <span class="keywordflow">if</span>(!AddStyleByIf(count)) <span class="keywordflow">return</span>;
<a name="l01416"></a>01416         <span class="keyword">const</span> <span class="keywordtype">int</span> PosX = BxDrawGlobal::_DrawOption::CurHotspotX();
<a name="l01417"></a>01417         <span class="keyword">const</span> <span class="keywordtype">int</span> PosY = BxDrawGlobal::_DrawOption::CurHotspotY();
<a name="l01418"></a>01418         <span class="keyword">const</span> <span class="keywordtype">int</span> X1 = PosX + r.l;
<a name="l01419"></a>01419         <span class="keyword">const</span> <span class="keywordtype">int</span> Y1 = PosY + r.t;
<a name="l01420"></a>01420         <span class="keyword">const</span> <span class="keywordtype">int</span> X2 = PosX + r.r;
<a name="l01421"></a>01421         <span class="keyword">const</span> <span class="keywordtype">int</span> Y2 = PosY + r.b;
<a name="l01422"></a>01422         <span class="comment">// 수정중...///////////////////////////////////////////</span>
<a name="l01423"></a>01423         <span class="keywordflow">if</span>(Y1 != Y2)
<a name="l01424"></a>01424         {
<a name="l01425"></a>01425 <span class="preprocessor">            #ifdef __BX_PIXEL16</span>
<a name="l01426"></a>01426 <span class="preprocessor"></span>                <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (5 + 5)];
<a name="l01427"></a>01427                 <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 5 + 4)];
<a name="l01428"></a>01428 <span class="preprocessor">            #else</span>
<a name="l01429"></a>01429 <span class="preprocessor"></span>                <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (8 + 8)];
<a name="l01430"></a>01430                 <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 8 + 8)];
<a name="l01431"></a>01431 <span class="preprocessor">            #endif</span>
<a name="l01432"></a>01432 <span class="preprocessor"></span>            <span class="keyword">const</span> <span class="keywordtype">int</span> BeginX = (Y1 &lt; Y2)? X1 : X2, BeginY = (Y1 &lt; Y2)? Y1 : Y2;
<a name="l01433"></a>01433             <span class="keyword">const</span> <span class="keywordtype">int</span> EndX = (Y1 &gt; Y2)? X1 : X2, EndY = (Y1 &gt; Y2)? Y1 : Y2;
<a name="l01434"></a>01434             <span class="keyword">const</span> <span class="keywordtype">int</span> DistanceX = EndX - BeginX, DistanceY = EndY - BeginY;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436             pixel_dst* ScreenPtr = GetBackBufferPtr();
<a name="l01437"></a>01437             <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp; FormClass = *BxDrawGlobal::_DrawOption::CurForm();
<a name="l01438"></a>01438             <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01439"></a>01439             BxDrawForm::OnFormMethod FormMethod = BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormMethod
<a name="l01440"></a>01440                 (BxDrawGlobal::_DrawOption::CurMaskOperate(), BxDrawGlobal::_DrawOption::CurMaskFlag());
<a name="l01441"></a>01441             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(BxDrawGlobal::_DrawOption::CurClipRect().t, BeginY), yend = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(EndY, BxDrawGlobal::_DrawOption::CurClipRect().b); y &lt; yend; ++y)
<a name="l01442"></a>01442             {
<a name="l01443"></a>01443                 <span class="keyword">const</span> <span class="keywordtype">int</span> x1 = BeginX + DistanceX * (y - BeginY) / DistanceY;
<a name="l01444"></a>01444                 <span class="keyword">const</span> <span class="keywordtype">int</span> x2 = BeginX + DistanceX * (y + 1 - BeginY) / DistanceY;
<a name="l01445"></a>01445                 <span class="keyword">const</span> <span class="keywordtype">int</span> xbegin = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>((x1 &lt; x2)? x1 : x2, BxDrawGlobal::_DrawOption::CurClipRect().l);
<a name="l01446"></a>01446                 <span class="keyword">const</span> <span class="keywordtype">int</span> xend = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>((x1 &gt; x2)? x1 : x2, BxDrawGlobal::_DrawOption::CurClipRect().r - 1);
<a name="l01447"></a>01447                 <span class="keywordflow">if</span>(xbegin &lt;= xend)
<a name="l01448"></a>01448                 {
<a name="l01449"></a>01449                     <span class="comment">// 블렌딩준비</span>
<a name="l01450"></a>01450                     pixel_dst* Dst = &amp;ScreenPtr[xbegin + y * GetBackBufferPitch()];
<a name="l01451"></a>01451                     <span class="comment">// 백버퍼카피</span>
<a name="l01452"></a>01452                     FormMethod(FormClass, FormRect, Dst, xend - xbegin, xbegin &lt;&lt; 16, y &lt;&lt; 16, 1 &lt;&lt; 16, 0, BlendSpriteTable, BlendAlphaTable);
<a name="l01453"></a>01453                 }
<a name="l01454"></a>01454             }
<a name="l01455"></a>01455         }
<a name="l01456"></a>01456         SubStyle();
<a name="l01457"></a>01457 <span class="preprocessor">        #endif</span>
<a name="l01458"></a>01458 <span class="preprocessor"></span>    }
<a name="l01460"></a>01460 
<a name="l01462"></a>01462     <span class="keywordtype">void</span> Ellipse(BxDrawGlobal::option opt, <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> r, stack count = 0)
<a name="l01463"></a>01463     {
<a name="l01464"></a>01464         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01465"></a>01465 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01466"></a>01466 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01467"></a>01467         <span class="keywordflow">if</span>(AddStyleByIf(count))
<a name="l01468"></a>01468         {
<a name="l01470"></a>01470             SubStyle();
<a name="l01471"></a>01471         }
<a name="l01472"></a>01472 <span class="preprocessor">        #else</span>
<a name="l01473"></a>01473 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01474"></a>01474         <span class="keywordflow">if</span>(!AddStyleByIf(count)) <span class="keywordflow">return</span>;
<a name="l01475"></a>01475         SubStyle();
<a name="l01476"></a>01476 <span class="preprocessor">        #endif</span>
<a name="l01477"></a>01477 <span class="preprocessor"></span>    }
<a name="l01479"></a>01479 
<a name="l01486"></a><a class="code" href="class_bx_draw.html#a3fcdf4a85cf9faf2cac38722fa70e7de">01486</a>     <span class="keywordtype">void</span> PolygonSt(BxDrawGlobal::option opt, <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a> p, stack count = 0)
<a name="l01487"></a>01487     {
<a name="l01488"></a>01488         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01489"></a>01489 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01491"></a>01491         <span class="keywordflow">if</span>(AddStyleByIf(count))
<a name="l01492"></a>01492         {
<a name="l01493"></a>01493             <span class="keyword">const</span> <span class="keywordtype">int</span> FormWidth = BxDrawGlobal::_DrawOption::CurForm()-&gt;Width();
<a name="l01494"></a>01494             <span class="keyword">const</span> <span class="keywordtype">int</span> FormHeight = BxDrawGlobal::_DrawOption::CurForm()-&gt;Height();
<a name="l01495"></a>01495             <span class="keyword">const</span> <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a>&amp; FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01496"></a>01496             <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> uvclip;
<a name="l01497"></a>01497             uvclip.l = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.l, FormWidth) / FormWidth);
<a name="l01498"></a>01498             uvclip.t = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.t, FormHeight) / FormHeight);
<a name="l01499"></a>01499             uvclip.r = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.r, FormWidth) / FormWidth);
<a name="l01500"></a>01500             uvclip.b = (short) ((1 &lt;&lt; 12) * <a class="code" href="namespace_bx_util_global.html#ab3bbc4ea5f14c15a837e50f2a216271e" title="최소최대 한계설정">BxUtilGlobal::MinMax</a>(0, FormRect.b, FormHeight) / FormHeight);
<a name="l01501"></a>01501             id_opengl_outline Outline = BxCore::OpenGL2D::MakeOutline_PolyVertexUV(p, uvclip);
<a name="l01502"></a>01502             <span class="keywordflow">if</span>(Outline)
<a name="l01503"></a>01503             {
<a name="l01504"></a>01504                 <span class="keyword">const</span> <span class="keywordtype">bool</span> DoFlip = (BxDrawGlobal::_DrawOption::CurTurn() % 2 == 1);
<a name="l01505"></a>01505                 <span class="keyword">const</span> <span class="keywordtype">int</span> Angle = ((1024 &lt;&lt; 16) + (BxDrawGlobal::_DrawOption::CurAngle() + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256)) % 1024;
<a name="l01506"></a>01506                 BxCore::OpenGL2D::Outline_PolyVertexUV_SetScale(Outline, BxDrawGlobal::_DrawOption::CurScaleHor(), BxDrawGlobal::_DrawOption::CurScaleVer());
<a name="l01507"></a>01507                 BxCore::OpenGL2D::Outline_PolyVertexUV_SetRotate(Outline, Angle, DoFlip);
<a name="l01508"></a>01508                 BxCore::OpenGL2D::Render(BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormGL(), Outline,
<a name="l01509"></a>01509                     BxDrawGlobal::_DrawOption::CurHotspotX(), BxDrawGlobal::_DrawOption::CurHotspotY(),
<a name="l01510"></a>01510                     255 * (BxDrawGlobal::_DrawOption::CurOpacity7() + 1) / 8,
<a name="l01511"></a>01511                     BxDrawGlobal::_DrawOption::CurColor());
<a name="l01512"></a>01512                 BxCore::OpenGL2D::FreeOutline(Outline);
<a name="l01513"></a>01513             }
<a name="l01514"></a>01514             SubStyle();
<a name="l01515"></a>01515         }
<a name="l01516"></a>01516 <span class="preprocessor">        #else</span>
<a name="l01517"></a>01517 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01518"></a>01518         <span class="keywordflow">if</span>(!AddStyleByIf(count)) <span class="keywordflow">return</span>;
<a name="l01519"></a>01519         <span class="keyword">const</span> <span class="keywordtype">bool</span> DoFlip = (BxDrawGlobal::_DrawOption::CurTurn() % 2 == 1);
<a name="l01520"></a>01520         <span class="keyword">const</span> <span class="keywordtype">int</span> Angle1 = ((1024 &lt;&lt; 16) + (BxDrawGlobal::_DrawOption::CurAngle() + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256)) % 1024;
<a name="l01521"></a>01521         <span class="keyword">const</span> <span class="keywordtype">int</span> Angle2 = ((1024 &lt;&lt; 16) - (BxDrawGlobal::_DrawOption::CurAngle() + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256)) % 1024;
<a name="l01522"></a>01522         <span class="keyword">const</span> huge Cos1 = <a class="code" href="class_bx_util.html#a1d0271ff4863c0b8fbe8b7f9c1076653" title="Cos값 구하기">BxUtil::Cos</a>(Angle1);
<a name="l01523"></a>01523         <span class="keyword">const</span> huge Sin1 = <a class="code" href="class_bx_util.html#a19bef9b1c3c37b263ad5d68a9fb710d0" title="Sin값 구하기">BxUtil::Sin</a>(Angle1);
<a name="l01524"></a>01524         <span class="keyword">const</span> huge Cos2 = <a class="code" href="class_bx_util.html#a1d0271ff4863c0b8fbe8b7f9c1076653" title="Cos값 구하기">BxUtil::Cos</a>(Angle2);
<a name="l01525"></a>01525         <span class="keyword">const</span> huge Sin2 = <a class="code" href="class_bx_util.html#a19bef9b1c3c37b263ad5d68a9fb710d0" title="Sin값 구하기">BxUtil::Sin</a>(Angle2);
<a name="l01526"></a>01526         <span class="keyword">const</span> fint Hor = BxDrawGlobal::_DrawOption::CurScaleHor();
<a name="l01527"></a>01527         <span class="keyword">const</span> fint Ver = BxDrawGlobal::_DrawOption::CurScaleVer();
<a name="l01528"></a>01528         <span class="keyword">const</span> <span class="keywordtype">int</span> PosX = BxDrawGlobal::_DrawOption::CurHotspotX();
<a name="l01529"></a>01529         <span class="keyword">const</span> <span class="keywordtype">int</span> PosY = BxDrawGlobal::_DrawOption::CurHotspotY();
<a name="l01530"></a>01530         <span class="keyword">const</span> fint Half = 0x10000 / 2;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532         <span class="comment">// 클리핑</span>
<a name="l01533"></a>01533         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, p.count &lt;= 256);
<a name="l01534"></a>01534         <a class="code" href="structpoint.html" title="point구조체 : x, y">point</a> Vertex[256] = {{0,},};
<a name="l01535"></a>01535         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> VertexArea = {0,};
<a name="l01536"></a>01536         <span class="keyword">const</span> <span class="keywordtype">int</span> VertexCount = p.count;
<a name="l01537"></a>01537         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; VertexCount; ++i)
<a name="l01538"></a>01538         {
<a name="l01539"></a>01539             <span class="keyword">const</span> <span class="keywordtype">int</span> OX = (p.pt[i].x * Hor + Half) &gt;&gt; 16;
<a name="l01540"></a>01540             <span class="keyword">const</span> <span class="keywordtype">int</span> OY = (p.pt[i].y * Ver + Half) &gt;&gt; 16;
<a name="l01541"></a>01541             Vertex[i].x = (int)((OX * Cos1 - OY * Sin1 + Half) &gt;&gt; 16);
<a name="l01542"></a>01542             Vertex[i].y = (int)((OX * Sin1 + OY * Cos1 + Half) &gt;&gt; 16);
<a name="l01543"></a>01543             VertexArea.l = (i == 0)? Vertex[i].x : <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(VertexArea.l, Vertex[i].x);
<a name="l01544"></a>01544             VertexArea.t = (i == 0)? Vertex[i].y : <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(VertexArea.t, Vertex[i].y);
<a name="l01545"></a>01545             VertexArea.r = (i == 0)? Vertex[i].x + 1 : <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(VertexArea.r, Vertex[i].x + 1);
<a name="l01546"></a>01546             VertexArea.b = (i == 0)? Vertex[i].y + 1 : <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(VertexArea.b, Vertex[i].y + 1);
<a name="l01547"></a>01547         }
<a name="l01548"></a>01548         VertexArea.l = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(PosX + VertexArea.l, BxDrawGlobal::_DrawOption::CurClipRect().l);
<a name="l01549"></a>01549         VertexArea.t = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(PosY + VertexArea.t, BxDrawGlobal::_DrawOption::CurClipRect().t);
<a name="l01550"></a>01550         VertexArea.r = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(PosX + VertexArea.r, BxDrawGlobal::_DrawOption::CurClipRect().r);
<a name="l01551"></a>01551         VertexArea.b = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(PosY + VertexArea.b, BxDrawGlobal::_DrawOption::CurClipRect().b);
<a name="l01552"></a>01552 
<a name="l01553"></a>01553         <span class="comment">// 매핑초기화</span>
<a name="l01554"></a>01554         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> v = VertexArea.t; v &lt; VertexArea.b; ++v)
<a name="l01555"></a>01555         {
<a name="l01556"></a>01556             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 0] = 3;
<a name="l01557"></a>01557             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 1] = 1;
<a name="l01558"></a>01558             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 2] = VertexArea.l;
<a name="l01559"></a>01559             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 3] = VertexArea.r - 1;
<a name="l01560"></a>01560         }
<a name="l01561"></a>01561         <span class="comment">// 매핑</span>
<a name="l01562"></a>01562         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0, last_index = 0; p &lt; VertexCount; ++p)
<a name="l01563"></a>01563         {
<a name="l01564"></a>01564             <span class="keyword">const</span> <span class="keywordtype">int</span> next_p = (p + 1 &lt; VertexCount)? p + 1 : last_index;
<a name="l01565"></a>01565             <span class="keyword">const</span> <span class="keywordtype">int</span> X1 = PosX + Vertex[p].x;
<a name="l01566"></a>01566             <span class="keyword">const</span> <span class="keywordtype">int</span> Y1 = PosY + Vertex[p].y;
<a name="l01567"></a>01567             <span class="keyword">const</span> <span class="keywordtype">int</span> X2 = PosX + Vertex[next_p].x;
<a name="l01568"></a>01568             <span class="keyword">const</span> <span class="keywordtype">int</span> Y2 = PosY + Vertex[next_p].y;
<a name="l01569"></a>01569             <span class="keywordflow">if</span>(Y1 != Y2)
<a name="l01570"></a>01570             {
<a name="l01571"></a>01571                 <span class="keyword">const</span> <span class="keywordtype">bool</span> IsBigY2 = (Y1 &lt; Y2);
<a name="l01572"></a>01572                 <span class="keyword">const</span> <span class="keywordtype">int</span> BeginX = (IsBigY2)? X1 : X2, BeginY = (IsBigY2)? Y1 : Y2;
<a name="l01573"></a>01573                 <span class="keyword">const</span> <span class="keywordtype">int</span> EndX = (IsBigY2)? X2 : X1, EndY = (IsBigY2)? Y2 : Y1;
<a name="l01574"></a>01574                 <span class="keyword">const</span> <span class="keywordtype">int</span> DistanceX = EndX - BeginX, DistanceY = EndY - BeginY;
<a name="l01575"></a>01575                 <span class="keyword">const</span> <span class="keywordtype">int</span> BeautifulValue = 1;
<a name="l01576"></a>01576                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(VertexArea.t, BeginY), yend = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(EndY, VertexArea.b); y &lt; yend; ++y)
<a name="l01577"></a>01577                 {
<a name="l01578"></a>01578                     <span class="keyword">const</span> <span class="keywordtype">int</span> x = BeginX + DistanceX * (y - BeginY + BeautifulValue) / (DistanceY + BeautifulValue);
<a name="l01579"></a>01579                     <span class="keywordflow">if</span>(x &lt;= FigureMap[(y &lt;&lt; FigureMapWidthLevel) | 2]) ++FigureMap[(y &lt;&lt; FigureMapWidthLevel) | 1];
<a name="l01580"></a>01580                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(x &lt; FigureMap[(y &lt;&lt; FigureMapWidthLevel) | FigureMap[y &lt;&lt; FigureMapWidthLevel]])
<a name="l01581"></a>01581                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> f = 3, fend = FigureMap[y &lt;&lt; FigureMapWidthLevel] + 1; f &lt; fend; ++f)
<a name="l01582"></a>01582                         <span class="keywordflow">if</span>(x &lt; FigureMap[(y &lt;&lt; FigureMapWidthLevel) | f])
<a name="l01583"></a>01583                         {
<a name="l01584"></a>01584                             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = FigureMap[y &lt;&lt; FigureMapWidthLevel], sbegin = f; sbegin &lt;= s; --s)
<a name="l01585"></a>01585                                 FigureMap[(y &lt;&lt; FigureMapWidthLevel) | (s + 1)] = FigureMap[(y &lt;&lt; FigureMapWidthLevel) | s];
<a name="l01586"></a>01586                             FigureMap[(y &lt;&lt; FigureMapWidthLevel) | f] = x;
<a name="l01587"></a>01587                             ++FigureMap[y &lt;&lt; FigureMapWidthLevel];
<a name="l01588"></a>01588                             <span class="keywordflow">break</span>;
<a name="l01589"></a>01589                         }
<a name="l01590"></a>01590                 }
<a name="l01591"></a>01591             }
<a name="l01592"></a>01592             <span class="keywordflow">if</span>(next_p != last_index &amp;&amp; Vertex[next_p].x == Vertex[last_index].x &amp;&amp; Vertex[next_p].y == Vertex[last_index].y)
<a name="l01593"></a>01593                 last_index = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(++p + 1, VertexCount - 1);
<a name="l01594"></a>01594         }
<a name="l01595"></a>01595 
<a name="l01596"></a>01596         <span class="comment">// 출력</span>
<a name="l01597"></a>01597         <span class="keyword">const</span> <a class="code" href="structarea.html" title="area구조체 : w, h, hx, hy">area</a>&amp; FormArea = *BxDrawGlobal::_DrawOption::CurForm()-&gt;GetArea();
<a name="l01598"></a>01598         <span class="keyword">const</span> huge DeHor = Ox100000000 / Hor;
<a name="l01599"></a>01599         <span class="keyword">const</span> huge DeVer = Ox100000000 / Ver;
<a name="l01600"></a>01600         <span class="keyword">const</span> fint DrawAddX = (fint)((DeHor * Cos2) &gt;&gt; 16) * ((DoFlip)? -1 : 1);
<a name="l01601"></a>01601         <span class="keyword">const</span> fint DrawAddY = (fint)((DeVer * Sin2) &gt;&gt; 16);
<a name="l01602"></a>01602         <span class="keyword">const</span> fint SrcWidth = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, FormArea.w * Hor);
<a name="l01603"></a>01603         <span class="keyword">const</span> fint SrcHeight = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, FormArea.h * Ver);
<a name="l01604"></a>01604         <span class="keyword">const</span> fint SrcHotspotX = FormArea.hx * Hor;
<a name="l01605"></a>01605         <span class="keyword">const</span> fint SrcHotspotY = FormArea.hy * Ver;
<a name="l01606"></a>01606         <span class="keyword">const</span> fint AreaWidth = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, BxDrawForm::CalcTextureSize(FormArea.w) * Hor);
<a name="l01607"></a>01607         <span class="keyword">const</span> fint AreaHeight = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, BxDrawForm::CalcTextureSize(FormArea.h) * Ver);
<a name="l01608"></a>01608 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l01609"></a>01609 <span class="preprocessor"></span>            <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (5 + 5)];
<a name="l01610"></a>01610             <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 5 + 4)];
<a name="l01611"></a>01611 <span class="preprocessor">        #else</span>
<a name="l01612"></a>01612 <span class="preprocessor"></span>            <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (8 + 8)];
<a name="l01613"></a>01613             <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 8 + 8)];
<a name="l01614"></a>01614 <span class="preprocessor">        #endif</span>
<a name="l01615"></a>01615 <span class="preprocessor"></span>        pixel_dst* ScreenPtr = GetBackBufferPtr();
<a name="l01616"></a>01616         <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp; FormClass = *BxDrawGlobal::_DrawOption::CurForm();
<a name="l01617"></a>01617         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01618"></a>01618         BxDrawForm::OnFormMethod FormMethod = BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormMethod
<a name="l01619"></a>01619             (BxDrawGlobal::_DrawOption::CurMaskOperate(), BxDrawGlobal::_DrawOption::CurMaskFlag());
<a name="l01620"></a>01620         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = VertexArea.t; y &lt; VertexArea.b; ++y)
<a name="l01621"></a>01621         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> f = 2 + (FigureMap[(y &lt;&lt; FigureMapWidthLevel) | 1] % 2), fend = FigureMap[y &lt;&lt; FigureMapWidthLevel]; f &lt; fend; f += 2)
<a name="l01622"></a>01622         {
<a name="l01623"></a>01623             <span class="keyword">const</span> <span class="keywordtype">int</span> Left = FigureMap[(y &lt;&lt; FigureMapWidthLevel) | f];
<a name="l01624"></a>01624             <span class="keyword">const</span> <span class="keywordtype">int</span> Right = FigureMap[(y &lt;&lt; FigureMapWidthLevel) | (f + 1)] + 1;
<a name="l01625"></a>01625             <span class="keywordflow">if</span>(Left &lt; Right)
<a name="l01626"></a>01626             {
<a name="l01627"></a>01627                 <span class="keyword">const</span> fint RotateX = (fint)((Left - PosX) * Cos2 - (y - PosY) * Sin2);
<a name="l01628"></a>01628                 <span class="keyword">const</span> fint RotateY = (fint)((Left - PosX) * Sin2 + (y - PosY) * Cos2);
<a name="l01629"></a>01629                 <span class="keyword">const</span> fint DrawX = (fint)(((GetBeginAdd(RotateX, -SrcHotspotX, AreaWidth) - ((DoFlip)? SrcWidth : 0)) * ((DoFlip)? -DeHor : DeHor)) &gt;&gt; 16);
<a name="l01630"></a>01630                 <span class="keyword">const</span> fint DrawY = (fint)((GetBeginAdd(RotateY, -SrcHotspotY, AreaHeight) * DeVer) &gt;&gt; 16);
<a name="l01631"></a>01631                 FormMethod(FormClass, FormRect, &amp;ScreenPtr[Left + y * GetBackBufferPitch()], Right - Left, DrawX, DrawY, DrawAddX, DrawAddY, BlendSpriteTable, BlendAlphaTable);
<a name="l01632"></a>01632             }
<a name="l01633"></a>01633         }
<a name="l01634"></a>01634         SubStyle();
<a name="l01635"></a>01635 <span class="preprocessor">        #endif</span>
<a name="l01636"></a>01636 <span class="preprocessor"></span>    }
<a name="l01637"></a>01637 
<a name="l01639"></a>01639     <span class="keywordtype">void</span> PolygonBz(BxDrawGlobal::option opt, <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a> p, stack count = 0)
<a name="l01640"></a>01640     {
<a name="l01641"></a>01641         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01642"></a>01642 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01643"></a>01643 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01644"></a>01644         <span class="keywordflow">if</span>(AddStyleByIf(count))
<a name="l01645"></a>01645         {
<a name="l01647"></a>01647             SubStyle();
<a name="l01648"></a>01648         }
<a name="l01649"></a>01649 <span class="preprocessor">        #else</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span>        <span class="comment">// 모듈</span>
<a name="l01651"></a>01651         <span class="keywordflow">if</span>(!AddStyleByIf(count)) <span class="keywordflow">return</span>;
<a name="l01652"></a>01652         <span class="keyword">const</span> <span class="keywordtype">bool</span> DoFlip = (BxDrawGlobal::_DrawOption::CurTurn() % 2 == 1);
<a name="l01653"></a>01653         <span class="keyword">const</span> <span class="keywordtype">int</span> Angle1 = ((1024 &lt;&lt; 16) + (BxDrawGlobal::_DrawOption::CurAngle() + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256)) % 1024;
<a name="l01654"></a>01654         <span class="keyword">const</span> <span class="keywordtype">int</span> Angle2 = ((1024 &lt;&lt; 16) - (BxDrawGlobal::_DrawOption::CurAngle() + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256)) % 1024;
<a name="l01655"></a>01655         <span class="keyword">const</span> huge Cos1 = <a class="code" href="class_bx_util.html#a1d0271ff4863c0b8fbe8b7f9c1076653" title="Cos값 구하기">BxUtil::Cos</a>(Angle1);
<a name="l01656"></a>01656         <span class="keyword">const</span> huge Sin1 = <a class="code" href="class_bx_util.html#a19bef9b1c3c37b263ad5d68a9fb710d0" title="Sin값 구하기">BxUtil::Sin</a>(Angle1);
<a name="l01657"></a>01657         <span class="keyword">const</span> huge Cos2 = <a class="code" href="class_bx_util.html#a1d0271ff4863c0b8fbe8b7f9c1076653" title="Cos값 구하기">BxUtil::Cos</a>(Angle2);
<a name="l01658"></a>01658         <span class="keyword">const</span> huge Sin2 = <a class="code" href="class_bx_util.html#a19bef9b1c3c37b263ad5d68a9fb710d0" title="Sin값 구하기">BxUtil::Sin</a>(Angle2);
<a name="l01659"></a>01659         <span class="keyword">const</span> fint Hor = BxDrawGlobal::_DrawOption::CurScaleHor();
<a name="l01660"></a>01660         <span class="keyword">const</span> fint Ver = BxDrawGlobal::_DrawOption::CurScaleVer();
<a name="l01661"></a>01661         <span class="keyword">const</span> <span class="keywordtype">int</span> PosX = BxDrawGlobal::_DrawOption::CurHotspotX();
<a name="l01662"></a>01662         <span class="keyword">const</span> <span class="keywordtype">int</span> PosY = BxDrawGlobal::_DrawOption::CurHotspotY();
<a name="l01663"></a>01663         <span class="keyword">const</span> fint Half = 0x10000 / 2;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         <span class="comment">// 클리핑</span>
<a name="l01666"></a>01666         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, p.count &lt;= 256);
<a name="l01667"></a>01667         <a class="code" href="structpoint.html" title="point구조체 : x, y">point</a> Vertex[256] = {{0,},};
<a name="l01668"></a>01668         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> VertexArea = {0,};
<a name="l01669"></a>01669         <span class="keyword">const</span> <span class="keywordtype">int</span> VertexCount = p.count;
<a name="l01670"></a>01670         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; VertexCount; ++i)
<a name="l01671"></a>01671         {
<a name="l01672"></a>01672             <span class="keyword">const</span> <span class="keywordtype">int</span> OX = (p.pt[i].x * Hor + Half) &gt;&gt; 16;
<a name="l01673"></a>01673             <span class="keyword">const</span> <span class="keywordtype">int</span> OY = (p.pt[i].y * Ver + Half) &gt;&gt; 16;
<a name="l01674"></a>01674             Vertex[i].x = (int)((OX * Cos1 - OY * Sin1 + Half) &gt;&gt; 16);
<a name="l01675"></a>01675             Vertex[i].y = (int)((OX * Sin1 + OY * Cos1 + Half) &gt;&gt; 16);
<a name="l01676"></a>01676             VertexArea.l = (i == 0)? Vertex[i].x : <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(VertexArea.l, Vertex[i].x);
<a name="l01677"></a>01677             VertexArea.t = (i == 0)? Vertex[i].y : <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(VertexArea.t, Vertex[i].y);
<a name="l01678"></a>01678             VertexArea.r = (i == 0)? Vertex[i].x + 1 : <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(VertexArea.r, Vertex[i].x + 1);
<a name="l01679"></a>01679             VertexArea.b = (i == 0)? Vertex[i].y + 1 : <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(VertexArea.b, Vertex[i].y + 1);
<a name="l01680"></a>01680         }
<a name="l01681"></a>01681         VertexArea.l = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(PosX + VertexArea.l, BxDrawGlobal::_DrawOption::CurClipRect().l);
<a name="l01682"></a>01682         VertexArea.t = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(PosY + VertexArea.t, BxDrawGlobal::_DrawOption::CurClipRect().t);
<a name="l01683"></a>01683         VertexArea.r = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(PosX + VertexArea.r, BxDrawGlobal::_DrawOption::CurClipRect().r);
<a name="l01684"></a>01684         VertexArea.b = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(PosY + VertexArea.b, BxDrawGlobal::_DrawOption::CurClipRect().b);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686         <span class="comment">// 매핑초기화</span>
<a name="l01687"></a>01687         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> v = VertexArea.t; v &lt; VertexArea.b; ++v)
<a name="l01688"></a>01688         {
<a name="l01689"></a>01689             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 0] = 3;
<a name="l01690"></a>01690             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 1] = 1;
<a name="l01691"></a>01691             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 2] = VertexArea.l;
<a name="l01692"></a>01692             FigureMap[(v &lt;&lt; FigureMapWidthLevel) | 3] = VertexArea.r - 1;
<a name="l01693"></a>01693         }
<a name="l01694"></a>01694         <span class="comment">// 매핑</span>
<a name="l01695"></a>01695         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 1, last_index = 0; l &lt;= VertexCount; ++l)
<a name="l01696"></a>01696         {
<a name="l01697"></a>01697             <span class="keywordflow">if</span>(l &lt; VertexCount &amp;&amp; (Vertex[l].x != Vertex[last_index].x || Vertex[l].y != Vertex[last_index].y))
<a name="l01698"></a>01698                 <span class="keywordflow">continue</span>;
<a name="l01699"></a>01699             <span class="keywordflow">if</span>(2 &lt; l - last_index)
<a name="l01700"></a>01700             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = last_index; m &lt; l; ++m)
<a name="l01701"></a>01701             {
<a name="l01702"></a>01702                 <span class="keyword">const</span> <span class="keywordtype">int</span> UnitHalf = 16, UnitMax = UnitHalf * 2, UnitMaxPow2 = 2 * UnitMax * UnitMax;
<a name="l01703"></a>01703                 <span class="keyword">const</span> <span class="keywordtype">int</span> IndexA = (last_index &lt;= m - 1)? m - 1 : l - 1;
<a name="l01704"></a>01704                 <span class="keyword">const</span> <span class="keywordtype">int</span> IndexB = m;
<a name="l01705"></a>01705                 <span class="keyword">const</span> <span class="keywordtype">int</span> IndexC = (m + 1 &lt; l)? m + 1 : last_index;
<a name="l01706"></a>01706                 <span class="keywordtype">int</span> OldX = 0, OldY = 0;
<a name="l01707"></a>01707                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt;= UnitMax; ++n)
<a name="l01708"></a>01708                 {
<a name="l01709"></a>01709                     <span class="keyword">const</span> <span class="keywordtype">int</span> RateA = (UnitMax - n) * (UnitMax - n);
<a name="l01710"></a>01710                     <span class="keyword">const</span> <span class="keywordtype">int</span> RateB = UnitMaxPow2 - (((UnitHalf - n) * (UnitHalf - n)) &lt;&lt; 2);
<a name="l01711"></a>01711                     <span class="keyword">const</span> <span class="keywordtype">int</span> RateC = n * n;
<a name="l01712"></a>01712                     <span class="keyword">const</span> <span class="keywordtype">int</span> RateSum = RateA + RateB + RateC;
<a name="l01713"></a>01713                     <span class="keyword">const</span> <span class="keywordtype">int</span> CurX = PosX + (Vertex[IndexA].x * RateA + Vertex[IndexB].x * RateB + Vertex[IndexC].x * RateC) / RateSum;
<a name="l01714"></a>01714                     <span class="keyword">const</span> <span class="keywordtype">int</span> CurY = PosY + (Vertex[IndexA].y * RateA + Vertex[IndexB].y * RateB + Vertex[IndexC].y * RateC) / RateSum;
<a name="l01715"></a>01715                     <span class="keywordflow">if</span>(n &amp;&amp; OldY != CurY)
<a name="l01716"></a>01716                     {
<a name="l01717"></a>01717                         <span class="keyword">const</span> <span class="keywordtype">bool</span> IsBigY2 = (OldY &lt; CurY);
<a name="l01718"></a>01718                         <span class="keyword">const</span> <span class="keywordtype">int</span> BeginX = (IsBigY2)? OldX : CurX, BeginY = (IsBigY2)? OldY : CurY;
<a name="l01719"></a>01719                         <span class="keyword">const</span> <span class="keywordtype">int</span> EndX = (IsBigY2)? CurX : OldX, EndY = (IsBigY2)? CurY : OldY;
<a name="l01720"></a>01720                         <span class="keyword">const</span> <span class="keywordtype">int</span> DistanceX = EndX - BeginX, DistanceY = EndY - BeginY;
<a name="l01721"></a>01721                         <span class="keyword">const</span> <span class="keywordtype">int</span> BeautifulValue = 1;
<a name="l01722"></a>01722                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(VertexArea.t, BeginY), yend = <a class="code" href="namespace_bx_util_global.html#af6b6936a90b9f791ce6f2b2b4d15b15e" title="최소값 구하기">BxUtilGlobal::Min</a>(EndY, VertexArea.b); y &lt; yend; ++y)
<a name="l01723"></a>01723                         {
<a name="l01724"></a>01724                             <span class="keyword">const</span> <span class="keywordtype">int</span> x = BeginX + DistanceX * (y - BeginY + BeautifulValue) / (DistanceY + BeautifulValue);
<a name="l01725"></a>01725                             <span class="keywordflow">if</span>(x &lt;= FigureMap[(y &lt;&lt; FigureMapWidthLevel) | 2]) ++FigureMap[(y &lt;&lt; FigureMapWidthLevel) | 1];
<a name="l01726"></a>01726                             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(x &lt; FigureMap[(y &lt;&lt; FigureMapWidthLevel) | FigureMap[y &lt;&lt; FigureMapWidthLevel]])
<a name="l01727"></a>01727                             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> f = 3, fend = FigureMap[y &lt;&lt; FigureMapWidthLevel] + 1; f &lt; fend; ++f)
<a name="l01728"></a>01728                                 <span class="keywordflow">if</span>(x &lt; FigureMap[(y &lt;&lt; FigureMapWidthLevel) | f])
<a name="l01729"></a>01729                                 {
<a name="l01730"></a>01730                                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = FigureMap[y &lt;&lt; FigureMapWidthLevel], sbegin = f; sbegin &lt;= s; --s)
<a name="l01731"></a>01731                                         FigureMap[(y &lt;&lt; FigureMapWidthLevel) | (s + 1)] = FigureMap[(y &lt;&lt; FigureMapWidthLevel) | s];
<a name="l01732"></a>01732                                     FigureMap[(y &lt;&lt; FigureMapWidthLevel) | f] = x;
<a name="l01733"></a>01733                                     ++FigureMap[y &lt;&lt; FigureMapWidthLevel];
<a name="l01734"></a>01734                                     <span class="keywordflow">break</span>;
<a name="l01735"></a>01735                                 }
<a name="l01736"></a>01736                         }
<a name="l01737"></a>01737                     }
<a name="l01738"></a>01738                     OldX = CurX;
<a name="l01739"></a>01739                     OldY = CurY;
<a name="l01740"></a>01740                 }
<a name="l01741"></a>01741             }
<a name="l01742"></a>01742             last_index = ++l;
<a name="l01743"></a>01743         }
<a name="l01744"></a>01744 
<a name="l01745"></a>01745         <span class="comment">// 출력</span>
<a name="l01746"></a>01746         <span class="keyword">const</span> <a class="code" href="structarea.html" title="area구조체 : w, h, hx, hy">area</a>&amp; FormArea = *BxDrawGlobal::_DrawOption::CurForm()-&gt;GetArea();
<a name="l01747"></a>01747         <span class="keyword">const</span> huge DeHor = Ox100000000 / Hor;
<a name="l01748"></a>01748         <span class="keyword">const</span> huge DeVer = Ox100000000 / Ver;
<a name="l01749"></a>01749         <span class="keyword">const</span> fint DrawAddX = (fint)((DeHor * Cos2) &gt;&gt; 16) * ((DoFlip)? -1 : 1);
<a name="l01750"></a>01750         <span class="keyword">const</span> fint DrawAddY = (fint)((DeVer * Sin2) &gt;&gt; 16);
<a name="l01751"></a>01751         <span class="keyword">const</span> fint SrcWidth = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, FormArea.w * Hor);
<a name="l01752"></a>01752         <span class="keyword">const</span> fint SrcHeight = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, FormArea.h * Ver);
<a name="l01753"></a>01753         <span class="keyword">const</span> fint SrcHotspotX = FormArea.hx * Hor;
<a name="l01754"></a>01754         <span class="keyword">const</span> fint SrcHotspotY = FormArea.hy * Ver;
<a name="l01755"></a>01755         <span class="keyword">const</span> fint AreaWidth = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, BxDrawForm::CalcTextureSize(FormArea.w) * Hor);
<a name="l01756"></a>01756         <span class="keyword">const</span> fint AreaHeight = <a class="code" href="namespace_bx_util_global.html#a52580a7f5dbd7722b56eab2e3167292f" title="최대값 구하기">BxUtilGlobal::Max</a>(1, BxDrawForm::CalcTextureSize(FormArea.h) * Ver);
<a name="l01757"></a>01757 <span class="preprocessor">        #ifdef __BX_PIXEL16</span>
<a name="l01758"></a>01758 <span class="preprocessor"></span>            <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (5 + 5)];
<a name="l01759"></a>01759             <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 5 + 4)];
<a name="l01760"></a>01760 <span class="preprocessor">        #else</span>
<a name="l01761"></a>01761 <span class="preprocessor"></span>            <span class="keyword">const</span> byte* BlendSpriteTable = &amp;BxDrawGlobal::_DrawOption::CurSpriteTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (8 + 8)];
<a name="l01762"></a>01762             <span class="keyword">const</span> byte* BlendAlphaTable = &amp;BxDrawGlobal::_DrawOption::CurAlphaTable()[BxDrawGlobal::_DrawOption::CurOpacity7() &lt;&lt; (3 + 8 + 8)];
<a name="l01763"></a>01763 <span class="preprocessor">        #endif</span>
<a name="l01764"></a>01764 <span class="preprocessor"></span>        pixel_dst* ScreenPtr = GetBackBufferPtr();
<a name="l01765"></a>01765         <a class="code" href="class_bx_draw_form.html" title="새로운 폼개발을 위한 인터페이스">BxDrawForm</a>&amp; FormClass = *BxDrawGlobal::_DrawOption::CurForm();
<a name="l01766"></a>01766         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> FormRect = BxDrawGlobal::_DrawOption::CurFormRect();
<a name="l01767"></a>01767         BxDrawForm::OnFormMethod FormMethod = BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormMethod
<a name="l01768"></a>01768             (BxDrawGlobal::_DrawOption::CurMaskOperate(), BxDrawGlobal::_DrawOption::CurMaskFlag());
<a name="l01769"></a>01769         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = VertexArea.t; y &lt; VertexArea.b; ++y)
<a name="l01770"></a>01770         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> f = 2 + (FigureMap[(y &lt;&lt; FigureMapWidthLevel) | 1] % 2), fend = FigureMap[y &lt;&lt; FigureMapWidthLevel]; f &lt; fend; f += 2)
<a name="l01771"></a>01771         {
<a name="l01772"></a>01772             <span class="keyword">const</span> <span class="keywordtype">int</span> Left = FigureMap[(y &lt;&lt; FigureMapWidthLevel) | f];
<a name="l01773"></a>01773             <span class="keyword">const</span> <span class="keywordtype">int</span> Right = FigureMap[(y &lt;&lt; FigureMapWidthLevel) | (f + 1)] + 1;
<a name="l01774"></a>01774             <span class="keywordflow">if</span>(Left &lt; Right)
<a name="l01775"></a>01775             {
<a name="l01776"></a>01776                 <span class="keyword">const</span> fint RotateX = (fint)((Left - PosX) * Cos2 - (y - PosY) * Sin2);
<a name="l01777"></a>01777                 <span class="keyword">const</span> fint RotateY = (fint)((Left - PosX) * Sin2 + (y - PosY) * Cos2);
<a name="l01778"></a>01778                 <span class="keyword">const</span> fint DrawX = (fint)(((GetBeginAdd(RotateX, -SrcHotspotX, AreaWidth) - ((DoFlip)? SrcWidth : 0)) * ((DoFlip)? -DeHor : DeHor)) &gt;&gt; 16);
<a name="l01779"></a>01779                 <span class="keyword">const</span> fint DrawY = (fint)((GetBeginAdd(RotateY, -SrcHotspotY, AreaHeight) * DeVer) &gt;&gt; 16);
<a name="l01780"></a>01780                 FormMethod(FormClass, FormRect, &amp;ScreenPtr[Left + y * GetBackBufferPitch()], Right - Left, DrawX, DrawY, DrawAddX, DrawAddY, BlendSpriteTable, BlendAlphaTable);
<a name="l01781"></a>01781             }
<a name="l01782"></a>01782         }
<a name="l01783"></a>01783         SubStyle();
<a name="l01784"></a>01784 <span class="preprocessor">        #endif</span>
<a name="l01785"></a>01785 <span class="preprocessor"></span>    }
<a name="l01787"></a>01787 
<a name="l01794"></a><a class="code" href="class_bx_draw.html#acce77fcd90b3ac8ba20994bafc32b417">01794</a>     <span class="keywordtype">void</span> Polygon3D(<a class="code" href="structvertexs.html" title="vertexs구조체 : count, {x, y, z}, ...">vertexs</a> v, <a class="code" href="structpoints.html" title="points구조체 : count, {x, y}, ...">points</a> uv, stack count = 0)
<a name="l01795"></a>01795     {
<a name="l01796"></a>01796         <span class="keywordflow">if</span>(!VisibleTest(count)) <span class="keywordflow">return</span>;
<a name="l01797"></a>01797         <span class="keywordflow">if</span>(!AddStyleByIf(count)) <span class="keywordflow">return</span>;
<a name="l01798"></a>01798 <span class="preprocessor">        #ifdef __BX_OPENGL</span>
<a name="l01799"></a>01799 <span class="preprocessor"></span>        id_opengl_outline Outline = BxCore::OpenGL2D::MakeOutline_PolyVertexUV3D(v, uv);
<a name="l01800"></a>01800         <span class="keywordflow">if</span>(Outline)
<a name="l01801"></a>01801         {
<a name="l01802"></a>01802             <span class="comment">//const bool DoFlip = (BxDrawGlobal::_DrawOption::CurTurn() % 2 == 1);</span>
<a name="l01803"></a>01803             <span class="comment">//const int Angle = ((1024 &lt;&lt; 16) + (BxDrawGlobal::_DrawOption::CurAngle() + BxDrawGlobal::_DrawOption::CurTurn() / 2 * 256)) % 1024;</span>
<a name="l01804"></a>01804             <span class="comment">//BxCore::OpenGL2D::Outline_PolyVertexUV_SetScale(Outline, BxDrawGlobal::_DrawOption::CurScaleHor(), BxDrawGlobal::_DrawOption::CurScaleVer());</span>
<a name="l01805"></a>01805             <span class="comment">//BxCore::OpenGL2D::Outline_PolyVertexUV_SetRotate(Outline, Angle, DoFlip);</span>
<a name="l01806"></a>01806             BxCore::OpenGL2D::Render3D(BxDrawGlobal::_DrawOption::CurForm()-&gt;GetFormGL(), Outline,
<a name="l01807"></a>01807                 BxDrawGlobal::_DrawOption::CurMoveX3D(), BxDrawGlobal::_DrawOption::CurMoveY3D(), BxDrawGlobal::_DrawOption::CurMoveZ3D(),
<a name="l01808"></a>01808                 255 * (BxDrawGlobal::_DrawOption::CurOpacity7() + 1) / 8,
<a name="l01809"></a>01809                 BxDrawGlobal::_DrawOption::CurColor());
<a name="l01810"></a>01810             BxCore::OpenGL2D::FreeOutline(Outline);
<a name="l01811"></a>01811         }
<a name="l01812"></a>01812 <span class="preprocessor">        #endif</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>        SubStyle();
<a name="l01814"></a>01814     }
<a name="l01815"></a>01815 
<a name="l01820"></a><a class="code" href="class_bx_draw.html#a77996972a9170e0954e32feb9c6247a9">01820</a>     <span class="keywordtype">void</span> Flush(<span class="keywordtype">bool</span> isInitOnly = <span class="keyword">false</span>)
<a name="l01821"></a>01821     {
<a name="l01822"></a>01822         <span class="keywordflow">if</span>(!isInitOnly)
<a name="l01823"></a>01823             <a class="code" href="namespace_bx_core_1_1_surface.html#abfe9836c517ee028a1e4a858b26b82ff" title="업데이트 및 백버퍼를 화면에 출력">BxCore::Surface::Flush</a>(BackBufferPtr, <span class="keyword">sizeof</span>(pixel_dst) * BackBufferWidth, BackBufferHeight, <span class="keyword">sizeof</span>(pixel_dst) * GetBackBufferPitch());
<a name="l01824"></a>01824         <span class="comment">// 버튼이벤트초기화</span>
<a name="l01825"></a>01825         <span class="keywordflow">if</span>(IsButtonEventFinished) ButtonLength = 0;
<a name="l01826"></a>01826         <span class="keywordflow">else</span> IsButtonEventFinished = <span class="keyword">true</span>;
<a name="l01827"></a>01827         <span class="comment">// 백버퍼초기화</span>
<a name="l01828"></a>01828         <span class="keywordflow">if</span>(BackBufferWidth != <a class="code" href="namespace_bx_core_1_1_surface.html#a1c489f29b14e4ce1d01ff05a30df4ba5" title="화면너비 구하기">BxCore::Surface::GetWidth</a>() || BackBufferHeight != <a class="code" href="namespace_bx_core_1_1_surface.html#a1c360a3e21f7c82b5d9fed34e2c3e2aa" title="화면높이 구하기">BxCore::Surface::GetHeight</a>())
<a name="l01829"></a>01829         {
<a name="l01830"></a>01830             BackBufferWidth = <a class="code" href="namespace_bx_core_1_1_surface.html#a1c489f29b14e4ce1d01ff05a30df4ba5" title="화면너비 구하기">BxCore::Surface::GetWidth</a>();
<a name="l01831"></a>01831             BackBufferHeight = <a class="code" href="namespace_bx_core_1_1_surface.html#a1c360a3e21f7c82b5d9fed34e2c3e2aa" title="화면높이 구하기">BxCore::Surface::GetHeight</a>();
<a name="l01832"></a>01832 <span class="preprocessor">            #ifndef __BX_OPENGL</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span>            BxDelete_Array(BackBufferPtr);
<a name="l01834"></a>01834             BackBufferPtr = BxNew_Array(pixel_dst, BackBufferWidth * BackBufferHeight);
<a name="l01835"></a>01835 <span class="preprocessor">            #endif</span>
<a name="l01836"></a>01836 <span class="preprocessor"></span>        }
<a name="l01837"></a>01837         <span class="comment">// 도형버퍼재할당</span>
<a name="l01838"></a>01838         <span class="keywordflow">if</span>(FigureMapHeight != BackBufferHeight)
<a name="l01839"></a>01839         {
<a name="l01840"></a>01840             FigureMapHeight = BackBufferHeight;
<a name="l01841"></a>01841             BxDelete_Array(FigureMap);
<a name="l01842"></a>01842             FigureMap = BxNew_Array(<span class="keywordtype">int</span>, FigureMapWidthFix * FigureMapHeight);
<a name="l01843"></a>01843         }
<a name="l01844"></a>01844         <span class="comment">// 스택초기화</span>
<a name="l01845"></a>01845         BxDrawGlobal::Stack().CountCurrently = 0;
<a name="l01846"></a>01846         SubStyle(<span class="keyword">true</span>);
<a name="l01847"></a>01847     }
<a name="l01848"></a>01848 
<a name="l01853"></a><a class="code" href="class_bx_draw.html#a46084f3199ec06bbd0a07f2cc59c363d">01853</a>     <span class="keywordtype">void</span> AddStyle(stack count)
<a name="l01854"></a>01854     {
<a name="l01855"></a>01855         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, count == BxDrawGlobal::Stack().CountCurrently);
<a name="l01856"></a>01856         BxDrawGlobal::Stack().Count[++BxDrawGlobal::Stack().CountFocus] = count;
<a name="l01857"></a>01857         BxDrawGlobal::Stack().CountCurrently = 0;
<a name="l01858"></a>01858     }
<a name="l01859"></a>01859 
<a name="l01866"></a><a class="code" href="class_bx_draw.html#af11467c2017eb776b2a89e9144e9e413">01866</a>     <span class="keywordtype">bool</span> AddStyleByIf(stack count, <span class="keywordtype">string</span> buttonName = null)
<a name="l01867"></a>01867     {
<a name="l01868"></a>01868         AddStyle(count);
<a name="l01869"></a>01869         <span class="keywordflow">if</span>(BxDrawGlobal::_DrawOption::CurClipRect().r &lt;= BxDrawGlobal::_DrawOption::CurClipRect().l
<a name="l01870"></a>01870             || BxDrawGlobal::_DrawOption::CurClipRect().b &lt;= BxDrawGlobal::_DrawOption::CurClipRect().t)
<a name="l01871"></a>01871         {
<a name="l01872"></a>01872             SubStyle();
<a name="l01873"></a>01873             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01874"></a>01874         }
<a name="l01875"></a>01875         <span class="keywordflow">if</span>(buttonName != null)
<a name="l01876"></a>01876         {
<a name="l01877"></a>01877             <span class="keywordflow">if</span>(IsButtonEventFinished)
<a name="l01878"></a>01878             {
<a name="l01879"></a>01879                 ButtonLength = 0;
<a name="l01880"></a>01880                 IsButtonEventFinished = <span class="keyword">false</span>;
<a name="l01881"></a>01881             }
<a name="l01882"></a>01882             BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, ButtonLength &lt; <span class="keyword">sizeof</span>(ButtonEvent) / <span class="keyword">sizeof</span>(ButtonEvent[0]));
<a name="l01883"></a>01883             ButtonEvent[ButtonLength++].SetEvent(buttonName, BxDrawGlobal::_DrawOption::CurClipRect());
<a name="l01884"></a>01884         }
<a name="l01885"></a>01885         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01886"></a>01886     }
<a name="l01887"></a>01887 
<a name="l01892"></a><a class="code" href="class_bx_draw.html#a0f0ad44b174221300cc2ac99afbc5325">01892</a>     <span class="keywordtype">void</span> SubStyle(<span class="keywordtype">bool</span> doAll = <span class="keyword">false</span>)
<a name="l01893"></a>01893     {
<a name="l01894"></a>01894         BxAssert(<span class="stringliteral">&quot;BxDraw&quot;</span>, BxDrawGlobal::Stack().CountCurrently == 0);
<a name="l01895"></a>01895         <span class="keywordflow">if</span>(doAll) BxDrawGlobal::Stack().Init(BackBufferWidth, BackBufferHeight);
<a name="l01896"></a>01896         <span class="keywordflow">else</span> BxDrawGlobal::Stack().Sub();
<a name="l01897"></a>01897     }
<a name="l01898"></a>01898 
<a name="l01899"></a>01899 <span class="keyword">public</span>:
<a name="l01901"></a>01901     <span class="comment">// 버튼이벤트</span>
<a name="l01902"></a>01902     <span class="keyword">class </span>_ButtonEvent
<a name="l01903"></a>01903     {
<a name="l01904"></a>01904     <span class="keyword">public</span>:
<a name="l01905"></a>01905         string_rw Name;
<a name="l01906"></a>01906         <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> Field;
<a name="l01907"></a>01907     <span class="keyword">public</span>:
<a name="l01908"></a>01908         _ButtonEvent() : Name(null) {}
<a name="l01909"></a>01909         <span class="keyword">virtual</span> ~_ButtonEvent() {BxDelete_Array(Name);}
<a name="l01910"></a>01910     <span class="keyword">public</span>:
<a name="l01911"></a>01911         <span class="keywordtype">void</span> SetEvent(<span class="keywordtype">string</span> name, <a class="code" href="structrect.html" title="rect구조체 : l, t, r, b">rect</a> field)
<a name="l01912"></a>01912         {
<a name="l01913"></a>01913             <span class="keyword">const</span> <span class="keywordtype">int</span> Length = <a class="code" href="namespace_bx_util_global.html#a677b3048a42145d09849067b4d4a73ce" title="스트링길이 구하기">BxUtilGlobal::StrLen</a>(name);
<a name="l01914"></a>01914             BxDelete_Array(Name);
<a name="l01915"></a>01915             Name = BxNew_Array(<span class="keywordtype">char</span>, Length + 1);
<a name="l01916"></a>01916             <a class="code" href="namespace_bx_core_1_1_util.html#a0371fbafa905afeb67c09fca85741db0" title="메모리 복사">BxCore::Util::MemMove</a>(Name, name, Length + 1);
<a name="l01917"></a>01917             Field = field;
<a name="l01918"></a>01918         }
<a name="l01919"></a>01919         <span class="keywordtype">void</span> DeleteEvent()
<a name="l01920"></a>01920         {
<a name="l01921"></a>01921             BxDelete_Array(Name);
<a name="l01922"></a>01922             Name = null;
<a name="l01923"></a>01923         }
<a name="l01924"></a>01924     } ButtonEvent[256], CapturedButtonEvent;
<a name="l01926"></a>01926 
<a name="l01928"></a>01928     <span class="keywordtype">int</span> ButtonLength;
<a name="l01929"></a>01929     <span class="keywordtype">bool</span> IsButtonEventFinished;
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="keyword">protected</span>:
<a name="l01934"></a>01934     <span class="comment">// 백버퍼정보</span>
<a name="l01935"></a>01935     <span class="keywordtype">int</span> BackBufferWidth;
<a name="l01936"></a>01936     <span class="keywordtype">int</span> BackBufferHeight;
<a name="l01937"></a>01937     pixel_dst* _arr_ BackBufferPtr;
<a name="l01938"></a>01938     <span class="comment">// 도형버퍼</span>
<a name="l01939"></a>01939     <span class="keyword">const</span> <span class="keywordtype">int</span> FigureMapWidthFix;
<a name="l01940"></a>01940     <span class="keyword">const</span> <span class="keywordtype">int</span> FigureMapWidthLevel;
<a name="l01941"></a>01941     <span class="keywordtype">int</span> FigureMapHeight;
<a name="l01942"></a>01942     <span class="keywordtype">int</span>* FigureMap;
<a name="l01944"></a>01944 
<a name="l01946"></a>01946     <span class="keyword">inline</span> <span class="keywordtype">bool</span> VisibleTest(stack count)
<a name="l01947"></a>01947     {
<a name="l01948"></a>01948         <span class="keywordflow">if</span>(BxDrawGlobal::_DrawOption::CurOpacity7() &lt; 0
<a name="l01949"></a>01949             || BxDrawGlobal::_DrawOption::CurScaleHor() == 0
<a name="l01950"></a>01950             || BxDrawGlobal::_DrawOption::CurScaleVer() == 0)
<a name="l01951"></a>01951         {
<a name="l01952"></a>01952             AddStyle(count);
<a name="l01953"></a>01953             SubStyle();
<a name="l01954"></a>01954             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01955"></a>01955         }
<a name="l01956"></a>01956         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01957"></a>01957     }
<a name="l01959"></a>01959 
<a name="l01961"></a>01961     <span class="keyword">inline</span> <span class="keywordtype">int</span> GetBeginAdd(<span class="keyword">const</span> <span class="keywordtype">int</span> Outline, <span class="keyword">const</span> <span class="keywordtype">int</span> DstBegin, <span class="keyword">const</span> <span class="keywordtype">int</span> SrcSize)
<a name="l01962"></a>01962     {
<a name="l01963"></a>01963         <span class="keyword">const</span> <span class="keywordtype">int</span> BeginPos = DstBegin - Outline;
<a name="l01964"></a>01964         <span class="keywordflow">if</span>(BeginPos &lt;= 0) <span class="keywordflow">return</span> -BeginPos % SrcSize;
<a name="l01965"></a>01965         <span class="keywordflow">return</span> SrcSize - 1 - ((BeginPos - 1) % SrcSize);
<a name="l01966"></a>01966     }
<a name="l01968"></a>01968 };
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Tue May 22 2012 01:29:37 for BxEngine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
